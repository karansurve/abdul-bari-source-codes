//DSA

//Recursion
/*
 #include <stdio.h>
 
 void fun(int n){
 if(n>0){
 printf("%d ",n);
 fun(n-1);
 }
 
 }
 int main(){
 int x=3;
 fun(3);
 printf("\n");
 return 0;
 }
 
 #include <stdio.h>
 
 void fun(int n){
 if(n>0){
 fun(n-1);
 printf("%d",n);
 }
 }
 int main(){
 fun(3);
 printf("\n");
 
 return 0;
 }
 
 
 //static and global
 
 #include <stdio.h>
 // we can even write int x = 0 globally here.It'll act as static only i.e only one copy of x gets created.
 int fun(int n){
 static int x = 0;
 if(n>0){
 x++;
 return fun(n-1)+x;
 }
 return 0;
 }
 int main(){
 int r;
 r=fun(5);
 printf("%d",r);
 return 0;
 }
 
 //tree recursion
 
 #include <stdio.h>
 
 void fun(int n){
 if(n>0){
 printf("%d",n);
 fun(n-1);
 fun(n-1);
 }
 }
 int main(){
 fun(3);
 printf("\n");
 return 0;
 }
 
 //indirect or cyclic recursion
 
 #include<stdio.h>
 void funB(int n);//just write the signature of function to use it in funA
 
 void funA(int n){
 if(n>0){
 printf("%d ",n);
 funB(n-1);
 }
 }
 
 void funB(int n){
 {
 if(n>1){
 printf("%d ",n);
 funA(n/2);
 }
 }
 }
 
 int main(){
 funA(20);
 return 0;
 }
 
 //nested recursion
 
 #include<stdio.h>
 int fun(int n){
 if(n>100)
 return n-10;
 return fun(fun(n+11));
 }
 int main(){
 int r = fun(100);
 printf("%d\n",r);
 return 0;
 }
 
 
 //sum of n using rec
 
 #include <stdio.h>
 
 int sum(int n){
 if(n==0)
 return 0;
 return sum(n-1)+n;
 }
 int main(){
 int r = sum(5);
 printf("%d\n",r);
 return 0;
 }
 
 //factorial
 
 #include <stdio.h>
 int fact(int n){
 if(n==0)
 return 1;
 return fact(n-1)*n;
 }
 int main(){
 int r = fact(5);
 printf("%d\n",r);
 return 0;
 }
 
 //power function
 
 #include <stdio.h>
 int pow(int m, int n){
 if(n==0)
 return 1;
 return pow(m, n-1)*m;
 }
 //OR
 int pow1(int m, int n){
 if(n==0)
 return 1;
 if(n%2==0)
 return pow1(m*m, n/2);
 return m * pow1(m*m, (n-1)/2);
 }
 
 int main(){
 int r = pow(2, 3);
 int s = pow1(3, 4);
 printf("%d\n",r);
 printf("%d\n",s);
 return 0;
 }
 
 //taylor series
 
 #include<stdio.h>
 
 double e(int x, int n){
 static double p=1,f=1;
 double r;
 if(n==0)
 return 1;
 r=e(x, n-1);
 p=p*x;
 f=f*n;
 return r+p/f;
 }
 int main(){
 printf("%lf \n",e(1,10));
 return 0;
 }
 
 //taylor method 2
 
 #include <stdio.h>
 
 double e(int x, int n){
 static double s=1;
 for(;n>0;n--)
 s=1+x*s/n;     //iterative
 return s;
 }
 
 int main(){
 printf("%lf \n",e(1, 10));
 return 0;
 }
 
 #include <stdio.h>
 
 double e(int x, int n){
 static double s=1;
 if(n==0)
 return s;
 s=1+x*s/n;
 return e(x, n-1);                     //recursive
 
 }
 
 int main(){
 printf("%lf \n",e(1, 10));
 return 0;
 }
 
 //fibonacci
 
 #include <stdio.h>
 
 int fib(int n){
 if(n<=1)
 return n;                           //recursive
 return fib(n-2)+fib(n-1);
 }
 int main(){
 printf("%d \n",fib(7));
 return 0;
 }
 
 #include <stdio.h>
 
 int fib(int n){
 int a=0,b=1,s=0,i;
 if(n<=1)
 return n;                       //iterative
 for(i=2;i<=n;i++){
 s=a+b;
 a=b;
 b=s;
 }
 return s;
 }
 
 int main(){
 printf("%d \n",fib(7));
 return 0;
 }
 
 //fibonacci series + with memoisation
 
 #include <stdio.h>
 
 int rfib(int n){
 if(n<=1) return n;
 return rfib(n-2)+rfib(n-1);
 }
 int F[10];
 
 int mfib(int n){
 if(n<=1){
 F[n]=n;
 return n;
 }
 else{
 if(F[n-2]==-1)
 F[n-2]=mfib(n-2);
 if(F[n-1]==-1)
 F[n-1]=mfib(n-1);
 
 return F[n-2]+F[n-1];
 }
 }
 
 int main(){
 int i ;
 for(i=0;i<10;i++)
 F[i]=-1;
 printf("%d \n",mfib(7));
 return 0;
 }
 
 //combination formula nCr
 
 #include <stdio.h>
 //iterative
 int fact(int n){
 if(n==0)
 return 1;
 return fact(n-1)*n;
 }
 
 int nCr(int n, int r){
 int num,den;
 num = fact(n);
 den = fact(r) * fact(n-r);
 return num/den;
 }
 
 //recursive
 int NCR(int n, int r){
 if(n==r || r==0)
 return 1;
 return NCR(n-1, r-1)+NCR(n-1, r);
 }
 
 int main(){
 printf("%d \n",nCr(5, 3));
 return 0;
 }
 
 //tower of hanoi
 
#include <stdio.h>

void TOH(int n, int A, int B, int C){
    if(n>0){
        TOH(n-1, A, C, B);
        printf("(%d, %d)\n",A,C);
        TOH(n-1, B, A, C);
    }
}

int main(){
    TOH(3, 1, 2, 3);
    return 0;
}

//arrays

#include <stdio.h>

int main(){
    int A[5];
   // int B[5] = {1,2,3,4,5};
    //int C[10] = {1,2,3};
    //int D[5] = {0};
    //int E[] = {2,4,6,8,10};
 
    for(int i=0; i<5; i++)
        printf("%u \n", &A[i]);
    return 0;
}

// static vs dynamic

#include <stdio.h>
#include <stdlib.h>
int main(){
    int A[5] = {2,4,6,8,10};
    int *p;
    int i;
    p=(int *)malloc(5*sizeof(int));
    p[0] = 3;
    p[1] = 5;
    p[2] = 7;
    p[3] = 9;
    p[4] = 11;
    
    for(i=0; i<5; i++)
        printf("%d ", A[i]);
    printf("\n");
    
    for(i=0; i<5; i++)
        printf("%d ", p[i]);
    printf("\n");
    return 0;
}
 

// increasing size of array

#include <stdio.h>
#include <stdlib.h>

int main(){
    int *p,*q,i;
      
    p = (int *)malloc(5*sizeof(int));
    p[0]=3;
    p[1]=5;
    p[2]=7;
    p[3]=11;
    p[4]=13;
    
    q = (int *)malloc(10*sizeof(int));
    
    for(i=0; i<5; i++)
        q[i]=p[i];
    
    free(p);
    p=q;
    q=NULL;
    
    return 0;
}
 

//creating a 2d array

#include <stdio.h>
#include <stdlib.h>

int main(){
    int A[3][4] = {{1,2,3,4},
                    {5,6,7,8},
                    {9,10,11,12}};
    
    for(int i=0; i<3; i++){
        for(int j=0; j<4; j++)
            printf("%d ", A[i][j]);
        printf("/n");
    }
    
    int *B[3];
    B[0] = (int *)malloc(4*sizeof(int));
    B[1] = (int *)malloc(4*sizeof(int));
    B[2] = (int *)malloc(4*sizeof(int));
   
    for(int i=0; i<3; i++){
        for(int j=0; j<4; j++)
            printf("%d ", B[i][j]);
        printf("/n");
    }
    
    
    int **C;
    C = (int **)malloc(3*sizeof(int *));
    C[0] = (int *)malloc(4*sizeof(int));
    C[1] = (int *)malloc(4*sizeof(int));
    C[2] = (int *)malloc(4*sizeof(int));
    
    for(int i=0; i<3; i++){
        for(int j=0; j<4; j++)
            printf("%d ", C[i][j]);
        printf("/n");
    }
    
    
    return 0;
}
 

// Array adt

#include <stdio.h>
#include <stdlib.h>

struct Array{
    int *A;      //required size array
    int size;
    int length;
};

void Display(struct Array arr){
    int i;
    printf("\nElements are\n");
    for(i=0; i<arr.length; i++)
        printf("%d ", arr.A[i]);
}

int main(){
    
    struct Array arr;
    int n,i;
    
    printf("Enter size of array : ");
    scanf("%d", &arr.size);
    
    arr.A = (int *)malloc(arr.size*sizeof(int));
    arr.length = 0;
    
    printf("Enter number of numbers : ");
    scanf("%d", &n);
    
    printf("Enter all elements \n");
    for(i=0; i<n; i++){
        scanf("%d", &arr.A[i]);
    }
    arr.length =n;
    
    Display(arr);
    
    return 0;
}
 

//2nd method

#include <stdio.h>
#include <stdlib.h>

struct Array{
    int A[20];        //fixed size array
    int size;
    int length;
};

void Display(struct Array arr){
    int i;
    printf("\nElements are\n");
    for(i=0; i<arr.length; i++)
        printf("%d ", arr.A[i]);
}

int main(){
    
    struct Array arr = {{2,3,4,5,6}, 20, 5};
    
    Display(arr);
    
    return 0;
}

 
//insert

#include <stdio.h>
#include <stdlib.h>

struct Array{
    int A[10];
    int size;
    int length;
};

void Display(struct Array arr){
    int i;
    printf("\nElements are\n");
    for(i=0; i<arr.length; i++)
        printf("%d ", arr.A[i]);
    
}

void Append(struct Array *arr, int x){
    if(arr->length < arr->size)
        arr->A[arr->length++] = x;
}

void Insert(struct Array *arr, int index, int x){
    int i;
    if(index>=0 && index<=arr->length){
        for(i=arr->length; i>index; i--)
            arr->A[i] = arr->A[i-1];
        arr->A[index] = x;
        arr->length++;
    }
    
}

int main(){
    struct Array arr = {{2,3,4,5,6}, 10, 5};
    //Append(&arr, 10);
    Insert(&arr, 2, 10);
    Display(arr);
    return 0;
}
 
 
//delete

#include <stdio.h>
#include <stdlib.h>

struct Array{
    int A[10];
    int size;
    int length;
};

void Display(struct Array arr){
    int i;
    printf("\nElements are\n");
    for(i=0; i<arr.length; i++)
        printf("%d ", arr.A[i]);
    
}


int Delete(struct Array *arr, int index){
    int x =0;
    int i;
    if(index>=0 && index<arr->length){
        x=arr->A[index];
        for(i=index; i<arr->length-1; i++)
            arr->A[i] = arr->A[i+1];
        arr->length--;
        return x;
    }
    return 0;
}

int main(){
    struct Array arr = {{2,3,4,5,6}, 10, 5};
    printf("%d\n", Delete(&arr, 4));
    Display(arr);
    return 0;
}
                    *** use '->' when struct Array *arr e.g. arr->length
                    *** use '.' when struct Array arr  e.g. arr.length
 
 

//linear search


#include <stdio.h>
#include <stdlib.h>

struct Array{
    int A[10];
    int size;
    int length;
};

void Display(struct Array arr){
    int i;
    printf("\nElements are\n");
    for(i=0; i<arr.length; i++)
        printf("%d ", arr.A[i]);
    
}

int LinearSearch(struct Array arr, int key){
    int i;
    for(i=0; i<arr.length; i++){
        if(key == arr.A[i])
            return i;
    }
    return -1;
}

int main(){
    struct Array arr = {{2,3,4,5,6}, 10, 5};
    printf("%d\n", LinearSearch(arr, 15));
    Display(arr);
    return 0;
}
 

//efficient linear Search


#include <stdio.h>
#include <stdlib.h>

struct Array{
    int A[10];
    int size;
    int length;
};

void Display(struct Array arr){
    int i;
    printf("\nElements are\n");
    for(i=0; i<arr.length; i++)
        printf("%d ", arr.A[i]);
    
}

void swap(int *x, int *y){
    int temp;
    temp = *x;
    *x = *y;
    *y = temp;
}

int LinearSearch(struct Array *arr, int key){
    int i;
    for(i=0; i<arr->length; i++){
        if(key == arr->A[i]){
            swap(&arr->A[i], &arr->A[i-1]);  //or move to head i.e swap(&arr->A[i],                                                        &arr->A[0]);
            return i;
        }
    }
    return -1;
}

int main(){
    struct Array arr = {{2,3,4,5,6}, 10, 5};
    printf("%d\n", LinearSearch(&arr, 5));
    Display(arr);
    return 0;
}
 

//binary search (iterative)


#include <stdio.h>
#include <stdlib.h>

struct Array{
    int A[10];
    int size;
    int length;
};

void Display(struct Array arr){
    int i;
    printf("\nElements are\n");
    for(i=0; i<arr.length; i++)
        printf("%d ", arr.A[i]);
    
}

int BinarySearch(struct Array arr, int key){
    int l,mid,h;
    l=0;
    h=arr.length-1;
    
    while(l<=h){
        mid = (l+h)/2;
        if(key==arr.A[mid])
            return mid;
        else if(key<arr.A[mid])
            h=mid-1;
        else
            l=mid+1;
    }
    
    return -1;
}

int main(){
    struct Array arr = {{2,3,4,5,6}, 10, 5};
    printf("%d\n", BinarySearch(arr, 5));
    Display(arr);
    return 0;
}



//binary search (recursive)


#include <stdio.h>
#include <stdlib.h>

struct Array{
    int A[10];
    int size;
    int length;
};

void Display(struct Array arr){
    int i;
    printf("\nElements are\n");
    for(i=0; i<arr.length; i++)
        printf("%d ", arr.A[i]);
    
}

int RBinSearch(int a[], int l, int h, int key){
    int mid;
    if(l<=h){
        mid=(l+h)/2;
        if(key==a[mid])
            return mid;
        else if(key<a[mid])
            return RBinSearch(a, l, mid-1, key);
        else
            return RBinSearch(a, mid+1, h, key);
    }
    return -1;
}

int main(){
    struct Array arr = {{2,3,4,5,6}, 10, 5};
    printf("%d\n", RBinSearch(arr.A, 0, arr.length, 3));
    Display(arr);
    return 0;
}
 

//get(), set(), max() on array

#include <stdio.h>
#include <stdlib.h>

struct Array{
    int A[10];
    int size;
    int length;
};

void Display(struct Array arr){
    int i;
    printf("\nElements are\n");
    for(i=0; i<arr.length; i++)
        printf("%d ", arr.A[i]);
    printf("\n");
}

int Get(struct Array arr, int index){
    if(index>=0 && index<arr.length)
        return arr.A[index];
    return -1;
}

void Set(struct Array *arr, int index, int x){
    if(index>=0 && index<arr->length)
        arr->A[index] = x;
}

int Max(struct Array arr){
    int max = arr.A[0];
    int i;
    for(i=1; i<arr.length; i++){
        if(arr.A[i]>max)
            max = arr.A[i];
    }
    return max;
}

int Min(struct Array arr){
    int min = arr.A[0];
    int i;
    for(i=1; i<arr.length; i++){
        if(arr.A[i]<min)
            min = arr.A[i];
    }
    return min;
}

int Sum(struct Array arr){
    int s=0;
    int i;
    for(i=0; i<arr.length; i++)
        s+=arr.A[i];
    return s;
}

float Avg(struct Array arr){
    return (float)Sum(arr)/arr.length;
}

int main(){
    struct Array arr = {{2,3,4,5,6}, 10, 5};
    
    printf("%d\n", Get(arr, 2));
    Set(&arr, 0, 15);
    printf("%d\n", Max(arr));
    printf("%d\n", Min(arr));
    printf("%d\n", Sum(arr));
    printf("%.2f\n", Avg(arr));
    
    Display(arr);
    return 0;
}
 

//reversing array


#include <stdio.h>
#include <stdlib.h>

struct Array{
    int A[10];
    int size;
    int length;
};

void Display(struct Array arr){
    int i;
    printf("\nElements are\n");
    for(i=0; i<arr.length; i++)
        printf("%d ", arr.A[i]);
    
}

void swap(int *x, int *y){
    int temp;
    temp = *x;
    *x = *y;
    *y = temp;
}

void Reverse(struct Array *arr){
    int *B;
    int i,j;
    
    B = (int *)malloc(arr->length*sizeof(int));
    
    for(i=arr->length-1, j=0; i>=0; i--, j++)
        B[j] = arr->A[i];
    
    for(i=0; i<arr->length; i++)
        arr->A[i] = B[i];
}

void Reverse2(struct Array *arr){           //2nd method
    int i,j;
    for(i=0,j=arr->length-1; i<j; i++,j--){
        swap(&arr->A[i], &arr->A[j]);
    }
}

int main(){
    struct Array arr = {{2,3,4,5,6}, 10, 5};
    //Reverse(&arr);
    Reverse2(&arr);
    Display(arr);
    return 0;
}
 
 

//related with sorted array(checking,making it sorted etc)


#include <stdio.h>
#include <stdlib.h>

struct Array{
    int A[10];
    int size;
    int length;
};

void Display(struct Array arr){
    int i;
    printf("\nElements are\n");
    for(i=0; i<arr.length; i++)
        printf("%d ", arr.A[i]);
    
}

void swap(int *x, int *y){
    int temp;
    temp = *x;
    *x = *y;
    *y = temp;
}

void InsertSort(struct Array *arr, int x){
    int i = arr->length-1;
    if(arr->length==arr->size)
        return;
    while (i>=0 && arr->A[i]>x) {
        arr->A[i+1] = arr->A[i];
        i--;
    }
    arr->A[i+1]=x;
    arr->length++;
}

int isSorted(struct Array arr){
    int i;
    for(i=0; i<arr.length-1; i++){
        if(arr.A[i] > arr.A[i+1])
            return 0;
    }
    return 1;
}

void Rearrange(struct Array *arr){
    int i,j;
    i=0;
    j=arr->length-1;
    
    while(i<j){
        while(arr->A[i]<0)
            i++;
        while(arr->A[i]>=0)
            j--;
        if(i<j)
            swap(&arr->A[i], &arr->A[j]);
    }
}

int main(){
    struct Array arr = {{2,-3,4,5,-6,7}, 10, 6};
    //InsertSort(&arr, 3);
    //printf("%d\n", isSorted(arr));
    Rearrange(&arr);
    Display(arr);
    return 0;
}

 

//merge


#include <stdio.h>
#include <stdlib.h>

struct Array {
    int A[10];
    int size;
    int length;
};

void Display(struct Array arr){
    int i;
    printf("\nElements are\n");
    for(i=0; i<arr.length; i++)
        printf("%d ", arr.A[i]);
}

struct Array* Merge(struct Array *arr1, struct Array *arr2){
    int i,j,k;
    i=j=k=0;
    
    struct Array *arr3 = (struct Array *)malloc(sizeof(struct Array));
    
    while(i<arr1->length && j<arr2->length){
        if(arr1->A[i]<arr2->A[j])
            arr3->A[k++] = arr1->A[i++];
        else
            arr3->A[k++] = arr2->A[j++];
    }
    for(;i<arr1->length;i++)
        arr3->A[k++] = arr1->A[i];
    
    for(;j<arr2->length;j++)
        arr3->A[k++] = arr2->A[j];
    
    arr3->length = arr1->length + arr2->length;
    arr3->size = 10;
    
    return arr3;
}

int main(){
    struct Array arr1 = {{2,6,10,15,25}, 10, 5};
    struct Array arr2 = {{3,4,7,18,20}, 10, 5};
    struct Array *arr3;
    
    arr3 = Merge(&arr1, &arr2);
    
    Display(*arr3);
    
    return 0;
}
 


//set operations

#include <stdio.h>
#include <stdlib.h>

struct Array {
    int A[10];
    int size;
    int length;
};

void Display(struct Array arr){
    int i;
    printf("\nElements are\n");
    for(i=0; i<arr.length; i++)
        printf("%d ", arr.A[i]);
}


struct Array* Union(struct Array *arr1, struct Array *arr2){
    int i,j,k;
    i=j=k=0;
    
    struct Array *arr3 = (struct Array *)malloc(sizeof(struct Array));
    
    while(i<arr1->length && j<arr2->length){
        if(arr1->A[i]<arr2->A[j])
            arr3->A[k++] = arr1->A[i++];
        else if(arr2->A[j]<arr1->A[i])
            arr3->A[k++] = arr2->A[j++];
        else{
            arr3->A[k++] = arr1->A[i++];
            j++;
        }
            
    }
    for(;i<arr1->length;i++)
        arr3->A[k++] = arr1->A[i];
    
    for(;j<arr2->length;j++)
        arr3->A[k++] = arr2->A[j];
    
    arr3->length = k;
    arr3->size = 10;
    
    return arr3;
}

struct Array* Intersection(struct Array *arr1, struct Array *arr2){
    int i,j,k;
    i=j=k=0;
    
    struct Array *arr3 = (struct Array *)malloc(sizeof(struct Array));
    
    while(i<arr1->length && j<arr2->length){
        if(arr1->A[i]<arr2->A[j])
            i++;
        else if(arr2->A[j]<arr1->A[i])
            j++;
        else if(arr1->A[i]==arr2->A[j]){
            arr3->A[k++] = arr1->A[i++];
            j++;
        }
            
    }
    
    arr3->length = k;
    arr3->size = 10;
    
    return arr3;
}

struct Array* Difference(struct Array *arr1, struct Array *arr2){
    int i,j,k;
    i=j=k=0;
    
    struct Array *arr3 = (struct Array *)malloc(sizeof(struct Array));
    
    while(i<arr1->length && j<arr2->length){
        if(arr1->A[i]<arr2->A[j])
            arr3->A[k++] = arr1->A[i++];
        else if(arr2->A[j]<arr1->A[i])
            j++;
        else{
            i++;
            j++;
        }
            
    }
    for(;i<arr1->length;i++)
        arr3->A[k++] = arr1->A[i];
    
    
    arr3->length = k;
    arr3->size = 10;
    
    return arr3;
}

int main(){
    struct Array arr1 = {{2,6,10,15,25}, 10, 5};
    struct Array arr2 = {{3,6,7,15,20}, 10, 5};
    struct Array *arr3;
    
   // arr3 = Union(&arr1, &arr2);
  //  arr3 = Intersection(&arr1, &arr2);
    arr3 = Difference(&arr1, &arr2);
    
    Display(*arr3);
    
    return 0;
}
 

//menu driven programs for all operations upon array


#include <stdio.h>
#include <stdlib.h>

struct Array{
    int *A;
    int size;
    int length;
};

//here all the operations will come i.e display, append, reverse....difference

int main(){
    struct Array arr1 ;
    int ch;
    
    printf("Enter size of the array : ");
    scanf("%d\n", &arr1.size);
    arr1.A = (int *)malloc(arr1.size*sizeof(int));
    
    do {
        printf("Menu\n");
        printf("1.Insert\n");
        printf("2.Delete\n");
        printf("3.Search\n");
        printf("4.Sum\n");
        printf("5.Display\n");
        printf("6.Exit\n");
        
        printf("Enter your choice : ");
        scanf("%d", &ch);
        
        switch(ch){
            case 1: printf("Enter an element and index : ");
                scanf("%d%d", &x, &index);
                Insert(&arr1, index, x);
                break;
            case 2: printf("Enter index ");
                scanf("%d",&index);
                x=Delete(&arr1,index);
                printf("Deleted Element is %d\n",x);
                break;
            case 3:printf("Enter element to search ");
                scanf("%d",&x);
                index=LinearSearch(&arr1,x);
                printf("Element index %d",index);
                break;
            case 4:printf("Sum is %d\n",Sum(arr1));
                break;
            case 5:Display(arr1);
                
        }
    }while(ch<6);
    return 0;
}
 

//converting in C++

#include <iostream>

#include <stdio.h>
#include <stdlib.h>

using namespace std;

class Array{
private:
    int *A;
    int size;
    int length;
    void swap(int *x, int *y);
    
public:
    Array(){
        size = 10;
        length = 0;
        A = new int[size];
    }
    
    Array(int sz){
        size = sz;
        length = 0;
        A = new int[size];
    }
    
    ~Array(){
        delete []A;
    }
    
    void Display();
    void Append(int x);
    void Insert(int index, int x);
    int LinearSearch(int key);
    int BinarySearch(int key);
  //  int RBinarySearch(int a[], int l, int h, int key);
    int Get(int index);
    void Set(int index, int x);
    int Max();
    int Min();
    int Sum();
    float Avg();
    void Reverse();
    void Reverse2();
    void InsertSort(int x);
    int isSorted();
    void Rearrange();
    Array* Merge(Array *arr2);
    Array* Union(Array *arr2);
    Array* Intersection(Array *arr2);
    Array* Difference(Array *arr2);
};

void Array:: Display(){
    int i;
    printf("\nElements are\n");
    for(i=0; i<length; i++)
        printf("%d ", A[i]);
}

// continue like this ...
 // in main() use new Array instead of malloc..



//Array using C++ modified
#include <iostream>
using namespace std;

class Array {
private:
    int *A;
    int size;
    int length;
    void swap(int *x, int *y);

public:
    Array() {
        size = 10;
        length = 0;
        A = new int[size];
    }
    Array(int sz) {
        size = sz;
        length = 0;
        A = new int[size];
    }
    ~Array() {
        delete[] A;
    }
    void Display();
    void Append(int x);
    void Insert(int index, int x);
    int Delete(int index);
    int LinearSearch(int key);
    int BinarySearch(int key);
    int Get(int index);
    void Set(int index, int x);
    int Max();
    int Min();
    int Sum();
    float Avg();
    void Reverse();
    void Reverse2();
    void InsertSort(int x);
    int isSorted();
    void Rearrange();
    Array* Merge(Array arr2);
    Array* Union(Array arr2);
    Array* Diff(Array arr2);
    Array* Inter(Array arr2);
};

void Array::Display() {
    int i;
    cout << "\nElements are\n";
    for (i = 0; i < length; i++)
        cout << A[i] << " ";
}

void Array::Append(int x) {
    if (length < size)
        A[length++] = x;
}

void Array::Insert(int index, int x) {
    int i;
    if (index >= 0 && index <= length) {
        for (i = length; i > index; i--)
            A[i] = A[i - 1];
        A[index] = x;
        length++;
    }
}

int Array::Delete(int index) {
    int x = 0;
    int i;

    if (index >= 0 && index < length) {
        x = A[index];
        for (i = index; i < length - 1; i++)
            A[i] = A[i + 1];
        length--;
        return x;
    }

    return 0;
}

void Array::swap(int *x, int *y) {
    int temp;
    temp = *x;
    *x = *y;
    *y = temp;
}

int Array::LinearSearch(int key) {
    int i;
    for (i = 0; i < length; i++) {
        if (key == A[i]) {
            swap(&A[i], &A[0]);
            return i;
        }
    }
    return -1;
}

int Array::BinarySearch(int key) {
    int l, mid, h;
    l = 0;
    h = length - 1;

    while (l <= h) {
        mid = (l + h) / 2;
        if (key == A[mid])
            return mid;
        else if (key < A[mid])
            h = mid - 1;
        else
            l = mid + 1;
    }
    return -1;
}

int Array::Get(int index) {
    if (index >= 0 && index < length)
        return A[index];
    return -1;
}

void Array::Set(int index, int x) {
    if (index >= 0 && index < length)
        A[index] = x;
}

int Array::Max() {
    int max = A[0];
    int i;
    for (i = 1; i < length; i++) {
        if (A[i] > max)
            max = A[i];
    }
    return max;
}

int Array::Min() {
    int min = A[0];
    int i;
    for (i = 1; i < length; i++) {
        if (A[i] < min)
            min = A[i];
    }
    return min;
}

int Array::Sum() {
    int s = 0;
    int i;
    for (i = 0; i < length; i++)
        s += A[i];
    return s;
}

float Array::Avg() {
    return (float)Sum() / length;
}

void Array::Reverse() {
    int *B;
    int i, j;

    B = (int *)malloc(length * sizeof(int));
    for (i = length - 1, j = 0; i >= 0; i--, j++)
        B[j] = A[i];
    for (i = 0; i < length; i++)
        A[i] = B[i];
    free(B);
}

void Array::Reverse2() {
    int i, j;
    for (i = 0, j = length - 1; i < j; i++, j--) {
        swap(&A[i], &A[j]);
    }
}

void Array::InsertSort(int x) {
    int i = length - 1;
    if (length == size)
        return;
    while (i >= 0 && A[i] > x) {
        A[i + 1] = A[i];
        i--;
    }
    A[i + 1] = x;
    length++;
}

int Array::isSorted() {
    int i;
    for (i = 0; i < length - 1; i++) {
        if (A[i] > A[i + 1])
            return 0;
    }
    return 1;
}

void Array::Rearrange() {
    int i, j;
    i = 0;
    j = length - 1;

    while (i < j) {
        while (A[i] < 0)
            i++;
        while (A[j] >= 0)
            j--;
        if (i < j)
            swap(&A[i], &A[j]);
    }
}

Array* Array::Merge(Array arr2) {
    int i, j, k;
    i = j = k = 0;

    Array *arr3 = new Array(length + arr2.length);

    while (i < length && j < arr2.length) {
        if (A[i] < arr2.A[j])
            arr3->A[k++] = A[i++];
        else
            arr3->A[k++] = arr2.A[j++];
    }
    for (; i < length; i++)
        arr3->A[k++] = A[i];
    for (; j < arr2.length; j++)
        arr3->A[k++] = arr2.A[j];
    arr3->length = length + arr2.length;

    return arr3;
}

Array* Array::Union(Array arr2) {
    int i, j, k;
    i = j = k = 0;

    Array *arr3 = new Array(length + arr2.length);

    while (i < length && j < arr2.length) {
        if (A[i] < arr2.A[j])
            arr3->A[k++] = A[i++];
        else if (arr2.A[j] < A[i])
            arr3->A[k++] = arr2.A[j++];
        else {
            arr3->A[k++] = A[i++];
            j++;
        }
    }
    for (; i < length; i++)
        arr3->A[k++] = A[i];
    for (; j < arr2.length; j++)
        arr3->A[k++] = arr2.A[j];

    arr3->length = k;

    return arr3;
}

Array* Array::Inter(Array arr2) {
    int i, j, k;
    i = j = k = 0;

    Array *arr3 = new Array(length + arr2.length);

    while (i < length && j < arr2.length) {
        if (A[i] < arr2.A[j])
            i++;
        else if (arr2.A[j] < A[i])
            j++;
        else if (A[i] == arr2.A[j]) {
            arr3->A[k++] = A[i++];
            j++;
        }
    }

    arr3->length = k;

    return arr3;
}

Array* Array::Diff(Array arr2) {
    int i, j, k;
    i = j = k = 0;

    Array *arr3 = new Array(length + arr2.length);

    while (i < length && j < arr2.length) {
        if (A[i] < arr2.A[j])
            arr3->A[k++] = A[i++];
        else if (arr2.A[j] < A[i])
            j++;
        else {
            i++;
            j++;
        }
    }
    for (; i < length; i++)
        arr3->A[k++] = A[i];

    arr3->length = k;

    return arr3;
}

int main() {
    Array *arr1;
    int ch, sz;
    int x, index;

    cout << "Enter Size of Array: ";
    cin >> sz;
    arr1 = new Array(sz);

    do {
        cout << "\n\nMenu\n";
        cout << "1. Insert\n";
        cout << "2. Delete\n";
        cout << "3. Search\n";
        cout << "4. Sum\n";
        cout << "5. Display\n";
        cout << "6. Exit\n";

        cout << "Enter your choice: ";
        cin >> ch;

        switch (ch) {
            case 1:
                cout << "Enter an element and index: ";
                cin >> x >> index;
                arr1->Insert(index, x);
                break;
            case 2:
                cout << "Enter index: ";
                cin >> index;
                x = arr1->Delete(index);
                cout << "Deleted Element is " << x;
                break;
            case 3:
                cout << "Enter element to search: ";
                cin >> x;
                index = arr1->LinearSearch(x);
                cout << "Element index " << index;
                break;
            case 4:
                cout << "Sum is " << arr1->Sum();
                break;
            case 5:
                arr1->Display();
                break;
        }
    } while (ch < 6);

    delete arr1;
    return 0;
}

 

// matrices
//diagonal

#include <stdio.h>

struct Matrix{
    int A[10];
    int n;
    
};

void Set(struct Matrix *m, int i, int j, int x){
    if(i==j)
        m->A[i-1] = x;
}

int Get(struct Matrix m, int i, int j){
    if(i==j)
        return m.A[i-1];
    else
        return 0;
}

void Display(struct Matrix m){
    int i,j;
    for(i=0; i<m.n; i++){
        for(j=0; j<m.n; j++){
            if(i==j)
                printf("%d ", m.A[i]);
            else
                printf("0 ");
        }
        printf("\n");
    }
}

int main(){
    struct Matrix m;
    m.n = 4;
    Set(&m, 1, 1, 5);
    Set(&m, 2, 2, 8);
    Set(&m, 3, 3, 9);
    Set(&m, 4, 4, 12);
    Display(m);
    return 0;
}
 


//diagonal in c++

#include <iostream>
using namespace std;

class Diagonal{
private:
    int *A;
    int n;
public:
    Diagonal(){
        n=2;
        A = new int[2];
    }
    Diagonal(int n){
        this->n = n;
        A = new int[n];
    }
    ~Diagonal(){
        delete []A;
    }
    void Set(int i, int j, int x);
    int Get(int i,int j);
    void Display();
};

void Diagonal::Set(int i, int j, int x){
    if(i==j)
        A[i-1]=x;
}

int Diagonal::Get(int i, int j){
    if(i==j)
        return A[i-1];
    return 0;
}

void Diagonal::Display(){
    for(int i=0; i<n; i++){
        for(int j=0; j<n; j++){
            if(i==j)
                cout<<A[i]<<" ";
            else
                cout<<"0 ";
        }
        cout<<endl;
    }
}

int main(){
    Diagonal d(4);
    d.Set(1, 1, 5);
    d.Set(2, 2, 8);
    d.Set(3, 3, 9);
    d.Set(4, 4, 12);
    d.Display();
    return 0;
}
 

//lower triangular(row major)

#include <stdio.h>
#include <stdlib.h>

struct Matrix{
    int *A;
    int n;
    
};

void Set(struct Matrix *m, int i, int j, int x){
    if(i>=j)
        m->A[i*(i-1)/2+j-1]=x;
    
}

int Get(struct Matrix m, int i, int j){
    if(i>=j)
        return m.A[i*(i-1)/2+j-1];
    else
        return 0;
}

void Display(struct Matrix m){
    int i,j;
    for(i=1; i<=m.n; i++){
        for(j=1; j<=m.n; j++){
            if(i>=j)
                printf("%d ", m.A[i*(i-1)/2+j-1]);
            else
                printf("0 ");
        }
        printf("\n");
    }
}

int main(){
    struct Matrix m;
    int i,j,x;
    printf("Enter dimension : ");
    scanf("%d", &m.n);
    m.A = (int *)malloc(m.n*(m.n-1)/2*sizeof(int));
    
    printf("Enter all elements");
    for(i=1; i<=m.n; i++){
        for(j=1; j<=m.n; j++){
            scanf("%d", &x);
            Set(&m, i, j, x);
        }
    }
    printf("\n\n");
    Display(m);
    return 0;
}
 


//lower triangular(column major)

#include <stdio.h>
#include <stdlib.h>

struct Matrix{
    int *A;
    int n;
    
};

void Set(struct Matrix *m, int i, int j, int x){
    if(i>=j)
        m->A[m->n*(j-1)+(j-2)*(j-1)/2+i-j]=x;
    
}

int Get(struct Matrix m, int i, int j){
    if(i>=j)
        return m.A[m.n*(j-1)+(j-2)*(j-1)/2+i-j];
    else
        return 0;
}

void Display(struct Matrix m){
    int i,j;
    for(i=1; i<=m.n; i++){
        for(j=1; j<=m.n; j++){
            if(i>=j)
                printf("%d ", m.A[m.n*(j-1)+(j-2)*(j-1)/2+i-j]);
            else
                printf("0 ");
        }
        printf("\n");
    }
}

int main(){
    struct Matrix m;
    int i,j,x;
    printf("Enter dimension : ");
    scanf("%d", &m.n);
    m.A = (int *)malloc(m.n*(m.n-1)/2*sizeof(int));
    
    printf("Enter all elements");
    for(i=1; i<=m.n; i++){
        for(j=1; j<=m.n; j++){
            scanf("%d", &x);
            Set(&m, i, j, x);
        }
    }
    printf("\n\n");
    Display(m);
    return 0;
}
 

//lower triangular in C++ (row major)

#include <iostream>
using namespace std;

class LowerTri{
private:
    int *A;
    int n;                          //for column major just change the formula at few places like before
public:
    LowerTri(){
        n=2;
        A = new int[2*(2+1)/2];
    }
    LowerTri(int n){
        this->n = n;
        A = new int[n*(n+1)/2];
    }
    ~LowerTri(){
        delete []A;
    }
    void Set(int i, int j, int x);
    int Get(int i,int j);
    void Display();
    int getDimension(){return n;}
};

void LowerTri::Set(int i, int j, int x){
    if(i>=j)
        A[i*(i-1)/2+j-1]=x;
}

int LowerTri::Get(int i, int j){
    if(i>=j)
        return A[i*(i-1)/2+j-1];
    return 0;
}

void LowerTri::Display(){
    for(int i=1; i<=n; i++){
        for(int j=1; j<=n; j++){
            if(i>=j)
                cout<<A[i*(i-1)/2+j-1]<<" ";
            else
                cout<<"0 ";
        }
        cout<<endl;
    }
}

int main(){
    int d;
    cout<<"Enter dimensions : ";
    cin>>d;
    
    LowerTri lm(d);
    
    int x;
    cout<<"Enter all elements : ";
    
    for(int i=1; i<=d; i++){
        for(int j=1; j<=d; j++){
            cin>>x;
            lm.Set(i, j, x);
        }
    }
    cout<<endl;
    lm.Display();
    
    return 0;
}
 

//sparse matrix

#include <stdio.h>
#include <stdlib.h>

struct Element{
    int i; //row no.
    int j; //col no.
    int x; //element
};

struct Sparse{
    int m; //rows
    int n; //col
    int num; //non-zero elements
    struct Element *ele;
};

void Create(struct Sparse *s){
    int i;
    printf("Enter dimensions : ");
    scanf("%d%d", &s->m,&s->n);
    printf("Number of non zero : ");
    scanf("%d", &s->num);
    
    s->ele = (struct Element *)malloc(s->num*sizeof(struct Element));
    printf("Enter non-zero elements : ");
    for(i=0; i<s->num; i++)
        scanf("%d%d%d", &s->ele[i].i, &s->ele[i].j, &s->ele[i].x);
}

void Display(struct Sparse s){
    int i,j,k=0;
    for(i=0; i<s.m; i++){
        for(j=0; j<s.n; j++){
            if(i==s.ele[k].i && j==s.ele[k].j)
                printf("%d ", s.ele[k++].x);
            else
                printf("0 ");
        }
        printf("\n");
    }
}

int main(){
    struct Sparse s;
    Create(&s);
    Display(s);
    return 0;
}
 

//add 2 sparse matrix

#include <stdio.h>
#include <stdlib.h>

struct Element {
    int i;
    int j;
    int x;
};

struct Sparse {
    int m;
    int n;
    int num;
    struct Element *ele;
};

void create(struct Sparse *s) {
    int i;

    printf("Enter Dimensions: ");
    scanf("%d%d", &s->m, &s->n);
    printf("Number of non-zero elements: ");
    scanf("%d", &s->num);

    s->ele = (struct Element *)malloc(s->num * sizeof(struct Element));
    printf("Enter non-zero Elements:\n");
    for (i = 0; i < s->num; i++)
        scanf("%d%d%d", &s->ele[i].i, &s->ele[i].j, &s->ele[i].x);
}

void display(struct Sparse s) {
    int i, j, k = 0;

    for (i = 0; i < s.m; i++) {
        for (j = 0; j < s.n; j++) {
            if (i == s.ele[k].i && j == s.ele[k].j)
                printf("%d ", s.ele[k++].x);
            else
                printf("0 ");
        }
        printf("\n");
    }
}

struct Sparse *add(struct Sparse *s1, struct Sparse *s2) {
    struct Sparse *sum;
    int i, j, k;
    i = j = k = 0;

    if (s1->n != s2->n || s1->m != s2->m)
        return NULL;

    sum = (struct Sparse *)malloc(sizeof(struct Sparse));
    sum->ele = (struct Element *)malloc((s1->num + s2->num) * sizeof(struct Element));
    while (i < s1->num && j < s2->num) {
        if (s1->ele[i].i < s2->ele[j].i)
            sum->ele[k++] = s1->ele[i++];
        else if (s1->ele[i].i > s2->ele[j].i)
            sum->ele[k++] = s2->ele[j++];
        else {
            if (s1->ele[i].j < s2->ele[j].j)
                sum->ele[k++] = s1->ele[i++];
            else if (s1->ele[i].j > s2->ele[j].j)
                sum->ele[k++] = s2->ele[j++];
            else {
                sum->ele[k] = s1->ele[i];
                sum->ele[k++].x = s1->ele[i++].x + s2->ele[j++].x;
            }
        }
    }
    for (; i < s1->num; i++)
        sum->ele[k++] = s1->ele[i];
    for (; j < s2->num; j++)
        sum->ele[k++] = s2->ele[j];
    sum->m = s1->m;
    sum->n = s1->n;
    sum->num = k;

    return sum;
}

int main() {
    struct Sparse s1, s2, *s3;

    create(&s1);
    create(&s2);

    s3 = add(&s1, &s2);

    printf("First Matrix:\n");
    display(s1);
    printf("Second Matrix:\n");
    display(s2);
    printf("Sum Matrix:\n");
    display(*s3);

    free(s1.ele);
    free(s2.ele);
    free(s3->ele);
    free(s3);

    return 0;
}
 

//sparse matrix in C++

#include <iostream>
using namespace std;

class Element{
public:
    int i;
    int j;
    int x;
    
};

class Sparse{
private:
    int m;
    int n;
    int num;
    Element *ele;
public:
    Sparse(int m, int n, int num){
        this->m=m;
        this->n=n;
        this->num=num;
        ele = new Element[this->num];
    }
    ~Sparse(){
        delete []ele;
    }
    
    void read(){
        cout<<"Enter non-zero elements : ";
        for(int i=0; i<num; i++){
            cin>>ele[i].i>>ele[i].j>>ele[i].x;
        }
    }
    
    void display(){
        int k=0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(ele[k].i==i && ele[k].j==j)
                    cout<<ele[k++].x<<" ";
                else
                    cout<<"0 ";
            }
            cout<<endl;
        }
    }
};

int main(){
    Sparse s1(5,5,5);
    s1.read();
    s1.display();
    
    return 0;
}
 

//addition for sparse matrix in C++

#include <iostream>
using namespace std;

class Element
{
public:
    int i;
    int j;
    int x;
};

class Sparse
{
private:
    int m;
    int n;
    int num;
    Element *ele;

public:
    Sparse(int m, int n, int num)
    {
        this->m = m;
        this->n = n;
        this->num = num;
        ele = new Element[this->num];
    }

    ~Sparse()
    {
        delete[] ele;
    }

    Sparse operator+(Sparse &s);

    friend istream &operator>>(istream &is, Sparse &s);
    friend ostream &operator<<(ostream &os, Sparse &s);
};

Sparse Sparse::operator+(Sparse &s)
{
    int i, j, k;
    if (m != s.m || n != s.n)
        return Sparse(0, 0, 0);
    Sparse *sum = new Sparse(m, n, num + s.num);

    i = j = k = 0;
    while (i < num && j < s.num)
    {
        if (ele[i].i < s.ele[j].i)
            sum->ele[k++] = ele[i++];
        else if (ele[i].i > s.ele[j].i)
            sum->ele[k++] = s.ele[j++];
        else
        {
            if (ele[i].j < s.ele[j].j)
                sum->ele[k++] = ele[i++];
            else if (ele[i].j > s.ele[j].j)
                sum->ele[k++] = s.ele[j++];
            else
            {
                sum->ele[k] = ele[i];
                sum->ele[k++].x = ele[i++].x + s.ele[j++].x;
            }
        }
    }
    for (; i < num; i++)
        sum->ele[k++] = ele[i];
    for (; j < s.num; j++)
        sum->ele[k++] = s.ele[j];
    sum->num = k;

    return *sum;
}

istream &operator>>(istream &is, Sparse &s)
{
    cout << "Enter non-zero elements";
    for (int i = 0; i < s.num; i++)
        cin >> s.ele[i].i >> s.ele[i].j >> s.ele[i].x;
    return is;
}

ostream &operator<<(ostream &os, Sparse &s)
{
    int k = 0;
    for (int i = 0; i < s.m; i++)
    {
        for (int j = 0; j < s.n; j++)
        {
            if (s.ele[k].i == i && s.ele[k].j == j)
                cout << s.ele[k++].x << " ";
            else
                cout << "0 ";
        }
        cout << endl;
    }
    return os;
}

int main()
{
    Sparse s1(5, 5, 5);
    Sparse s2(5, 5, 5);

    cin >> s1;
    cin >> s2;

    Sparse sum = s1 + s2;

    cout << "First Matrix" << endl << s1;
    cout << "Second Matrix" << endl << s2;
    cout << "Sum Matrix" << endl << sum;

    return 0;
}



//polynomial representation

#include <stdio.h>
#include <stdlib.h>

struct Term
{
    int coeff;
    int exp;
};

struct Poly
{
    int n;
    struct Term *terms;
};

void create(struct Poly *p)
{
    int i;
    printf("Number of terms?");
    scanf("%d", &p->n);
    p->terms = (struct Term *)malloc(p->n * sizeof(struct Term));

    printf("Enter terms\n");
    for (i = 0; i < p->n; i++)
        scanf("%d%d", &p->terms[i].coeff, &p->terms[i].exp);
}

void display(struct Poly p)
{
    int i;
    for (i = 0; i < p.n; i++)
        printf("%dx%d+", p.terms[i].coeff, p.terms[i].exp);
    printf("\n");
}

struct Poly *add(struct Poly *p1, struct Poly *p2)
{
    int i, j, k;
    struct Poly *sum;

    sum = (struct Poly *)malloc(sizeof(struct Poly));
    sum->terms = (struct Term *)malloc((p1->n + p2->n) * sizeof(struct Term));
    i = j = k = 0;

    while (i < p1->n && j < p2->n)
    {
        if (p1->terms[i].exp > p2->terms[j].exp)
            sum->terms[k++] = p1->terms[i++];
        else if (p1->terms[i].exp < p2->terms[j].exp)
            sum->terms[k++] = p2->terms[j++];
        else
        {
            sum->terms[k].exp = p1->terms[i].exp;
            sum->terms[k++].coeff = p1->terms[i++].coeff + p2->terms[j++].coeff;
        }
    }
    for (; i < p1->n; i++)
        sum->terms[k++] = p1->terms[i];
    for (; j < p2->n; j++)
        sum->terms[k++] = p2->terms[j];

    sum->n = k;
    return sum;
}

int main()
{
    struct Poly p1, p2, *p3;

    create(&p1);
    create(&p2);

    p3 = add(&p1, &p2);

    printf("\n");
    display(p1);
    printf("\n");
    display(p2);
    printf("\n");
    display(*p3);

    free(p1.terms);
    free(p2.terms);
    free(p3->terms);
    free(p3);

    return 0;
}
 

//Linked List
//Display

#include <stdio.h>
#include <stdlib.h>

struct Node{
    int data;
    struct Node *next;
}*first = NULL; //this is global that is it can be directly accessed or even pass it as parameter

void create(int A[], int n){
    int i;
    struct Node *t, *last;
    first = (struct Node *)malloc(sizeof(struct Node));
    first->data = A[0];
    first->next =NULL;
    last = first;
    
    for(i=1; i<n; i++){
        t=(struct Node *)malloc(sizeof(struct Node));
        t->data = A[i];
        t->next = NULL;
        last->next = t;
        last = t;
        
    }
}

void Display(struct Node *p){
    while(p!=NULL){
        printf("%d ", p->data);
        p=p->next;
    }
}

 void RDisplay(struct Node *p){
     if(p!=NULL){
         printf("%d ", p->data);            //recursive method
         RDisplay(p->next);
         
         //RDisplay(p->next);         //will display elements in reverse order
        //printf("%d ", p->data);
     }
 
 }
 
int main(){
    int A[] = {3,5,7,10,15};
    create(A, 5);
    Display(first);
    RDisplay(first);
    return 0;
}
 
 

//Counting nodes and sum of elements

#include <stdio.h>
#include <stdlib.h>

struct Node{
    int data;
    struct Node *next;
}*first = NULL; //this is global that is it can be directly accessed or even pass it as parameter

void create(int A[], int n){
    int i;
    struct Node *t, *last;
    first = (struct Node *)malloc(sizeof(struct Node));
    first->data = A[0];
    first->next =NULL;
    last = first;
    
    for(i=1; i<n; i++){
        t=(struct Node *)malloc(sizeof(struct Node));
        t->data = A[i];
        t->next = NULL;
        last->next = t;
        last = t;
        
    }
}

int count(struct Node *p){
    int l=0;
    while(p){
        l++;
        p=p->next;
    }
    return l;
}
 
int RCount(struct Node *p){
    if(p!=NULL){                        //recursive method
        return RCount(p->next)+1;
    }else
        return 0;
}

int sum(struct Node *p){
    int s=0;
    while(p!=NULL){
        s+=p->data;
        p=p->next;
    }
    return s;
}

int Rsum(struct Node *p){
    if(p==NULL)                 //recursive method
        return 0;
    return Rsum(p->next)+p->data;
}

int main(){
    int A[] = {3,5,7,10,15};
    create(A, 5);
    printf("Length is %d \n", count(first));
    printf("Length is %d \n", RCount(first));
    printf("Sum is %d \n", sum(first));
    printf("Sum is %d \n", Rsum(first));
    return 0;
}
 

//Max element


#include <stdio.h>
#include <stdlib.h>

struct Node{
    int data;
    struct Node *next;
}*first = NULL; //this is global that is it can be directly accessed or even pass it as parameter

void create(int A[], int n){
    int i;
    struct Node *t, *last;
    first = (struct Node *)malloc(sizeof(struct Node));
    first->data = A[0];
    first->next =NULL;
    last = first;
    
    for(i=1; i<n; i++){
        t=(struct Node *)malloc(sizeof(struct Node));
        t->data = A[i];
        t->next = NULL;
        last->next = t;
        last = t;
        
    }
}

int Max(struct Node *p){
    int max = INT32_MIN;
    while(p){
        if(p->data > max)
            max = p->data;
        p=p->next;
    }
    return max;
}

int RMax(struct Node *p){
    int x=0;
    
    if(p==0)
        return INT32_MIN;
    x=RMax(p->next);
    if(x>p->data)
        return x;
    return p->data;
    
}

int main(){
    int A[] = {3,5,7,10,15,8,12,20};
    create(A,8);
    printf("Max is %d \n", Max(first));
    printf("Max is %d \n", RMax(first));
    return 0;
}
 

//Linear Search

#include <stdio.h>
#include <stdlib.h>

struct Node{
    int data;
    struct Node *next;
}*first = NULL; //this is global that is it can be directly accessed or even pass it as parameter

void create(int A[], int n){
    int i;
    struct Node *t, *last;
    first = (struct Node *)malloc(sizeof(struct Node));
    first->data = A[0];
    first->next =NULL;
    last = first;
    
    for(i=1; i<n; i++){
        t=(struct Node *)malloc(sizeof(struct Node));
        t->data = A[i];
        t->next = NULL;
        last->next = t;
        last = t;
        
    }
}


struct Node *LSearch(struct Node *p, int key){
    while(p!=NULL){
        if(key==p->data)
            return p;                           //iterative
        p=p->next;
    }
    return NULL;
}

struct Node *LinSearch(struct Node *p, int key){
    struct Node *q = nullptr;
    
    while(p!=NULL){
        q=p;
        if(key==p->data){
            q->next = p->next;
            p->next = first;
            first = p;
            return p;                           //move to front method
        }
        
        p=p->next;
    }
    return NULL;
}

void Display(struct Node *p){
    while(p!=NULL){
        printf("%d ", p->data);
        p=p->next;
    }
}

struct Node *Rsearch(struct Node *p, int key){
    if(p==NULL)
        return NULL;
    if(key==p->data)
        return p;
    return Rsearch(p->next, key);
}

int main(){
    struct Node *temp;
    int A[] = {3,5,7,10,15,8,12,20};
    create(A,8);
    
    //temp = LSearch(first, 7);
    //temp = Rsearch(first, 7);
    temp = LinSearch(first, 7);
    if(temp)
        printf("Key is found %d \n",temp->data);
    else
        printf("Key not found\n");
    
    Display(first);
    return 0;
}

//inserting a new element in a LL

#include <stdio.h>
#include <stdlib.h>

struct Node{
    int data;
    struct Node *next;
}*first = NULL; //this is global that is it can be directly accessed or even pass it as parameter

void create(int A[], int n){
    int i;
    struct Node *t, *last;
    first = (struct Node *)malloc(sizeof(struct Node));
    first->data = A[0];
    first->next =NULL;
    last = first;
    
    for(i=1; i<n; i++){
        t=(struct Node *)malloc(sizeof(struct Node));
        t->data = A[i];
        t->next = NULL;
        last->next = t;
        last = t;
        
    }
}

int count(struct Node *p){
    int l=0;
    while(p){
        l++;
        p=p->next;
    }
    return l;
}

void Insert(struct Node *p, int index, int x){
    struct Node *t;
    int i;
    
    if(index <0 || index > count(p))
        return;
    t=(struct Node *)malloc(sizeof(struct Node));
    t->data = x;
    
    if(index == 0){
        t->next = first;
        first = t;
    }
    else{
        for(i=0; i<index-1; i++)
            p=p->next;
        t->next = p->next;
        p->next = t;
    }
    
}

void Display(struct Node *p){
    while(p!=NULL){
        printf("%d ", p->data);
        p=p->next;
    }
    printf("\n");
}

int main(){
    
    int A[] = {3,5,7};             //we can also create a new LL from scratch                                    using this
    create(A,3);
    Insert(first, 3, 10);
    Display(first);
    
    return 0;
}



//inserting in a sorted LL

#include <stdio.h>
#include <stdlib.h>

struct Node{
    int data;
    struct Node *next;
}*first = NULL; //this is global that is it can be directly accessed or even pass it as parameter

void create(int A[], int n){
    int i;
    struct Node *t, *last;
    first = (struct Node *)malloc(sizeof(struct Node));
    first->data = A[0];
    first->next =NULL;
    last = first;
    
    for(i=1; i<n; i++){
        t=(struct Node *)malloc(sizeof(struct Node));
        t->data = A[i];
        t->next = NULL;
        last->next = t;
        last = t;
        
    }
}

int count(struct Node *p){
    int l=0;
    while(p){
        l++;
        p=p->next;
    }
    return l;
}

void Display(struct Node *p){
    while(p!=NULL){
        printf("%d ", p->data);
        p=p->next;
    }
    printf("\n");
}

void SortedInsert(struct Node *p, int x){
    struct Node *t,*q=NULL;
    
    t=(struct Node *)malloc(sizeof(struct Node));
    t->data=x;
    t->next=NULL;
    
    if(first==NULL)
        first=t;
    else{
        while(p && p->data<x){
            q=p;
            p=p->next;
        }
        if(p==first){
            t->next=first;
            first=t;
        }
        else{
            t->next = q->next;
            q->next=t;
        }
    }
}

int main(){
    
    int A[] = {10,20,30,40,50};         //we can also create a new LL from scratch                                    using this
    create(A,5);
    SortedInsert(first, 35);
    
    Display(first);
    printf("\n");
    
    return 0;
}


//delete in a LL

#include <stdio.h>
#include <stdlib.h>

struct Node{
    int data;
    struct Node *next;
}*first = NULL; //this is global that is it can be directly accessed or even pass it as parameter

void create(int A[], int n){
    int i;
    struct Node *t, *last;
    first = (struct Node *)malloc(sizeof(struct Node));
    first->data = A[0];
    first->next =NULL;
    last = first;
    
    for(i=1; i<n; i++){
        t=(struct Node *)malloc(sizeof(struct Node));
        t->data = A[i];
        t->next = NULL;
        last->next = t;
        last = t;
        
    }
}

int count(struct Node *p){
    int l=0;
    while(p){
        l++;
        p=p->next;
    }
    return l;
}

void Display(struct Node *p){
    while(p!=NULL){
        printf("%d ", p->data);
        p=p->next;
    }
    printf("\n");
}

int Delete(struct Node *p, int index){
    struct Node *q=NULL;
    int x=-1,i;
    
    if(index < 1 || index > count(p))
        return -1;
    if(index==1){
        q=first;
        x=first->data;
        first=first->next;
        free(q);
        return x;
    }
    else{
        for(i=0; i<index-1; i++){
            q=p;
            p=p->next;
        }
        q->next = p->next;
        x=p->data;
        free(p);
        return x;
    }
}

int main(){
    
    int A[] = {10,20,30,40,50};
    create(A,5);
    printf("Deleted element is %d \n",Delete(first, 4));
    Display(first);
    printf("\n");
    
    return 0;
}


//to check if LL is sorted

#include <stdio.h>
#include <stdlib.h>

struct Node{
    int data;
    struct Node *next;
}*first = NULL; //this is global that is it can be directly accessed or even pass it as parameter

void create(int A[], int n){
    int i;
    struct Node *t, *last;
    first = (struct Node *)malloc(sizeof(struct Node));
    first->data = A[0];
    first->next =NULL;
    last = first;
    
    for(i=1; i<n; i++){
        t=(struct Node *)malloc(sizeof(struct Node));
        t->data = A[i];
        t->next = NULL;
        last->next = t;
        last = t;
        
    }
}

int isSorted(struct Node *p){
    int x = INT32_MIN;
    
    while(p!=NULL){
        if(p->data < x)
            return 0;
        x= p->data;
        p=p->next;
    }
    return 1;
}

int main(){
    
    int A[] = {10,2,30,40,50};
    create(A,5);
   // printf("%d\n", isSorted(first));
    if(isSorted(first))
        printf("Sorted\n");
    else
        printf("Not Sorted\n");
    return 0;
}
 

//removing duplicate elements from a sorted LL

#include <stdio.h>
#include <stdlib.h>

struct Node{
    int data;
    struct Node *next;
}*first = NULL; //this is global that is it can be directly accessed or even pass it as parameter

void create(int A[], int n){
    int i;
    struct Node *t, *last;
    first = (struct Node *)malloc(sizeof(struct Node));
    first->data = A[0];
    first->next =NULL;
    last = first;
    
    for(i=1; i<n; i++){
        t=(struct Node *)malloc(sizeof(struct Node));
        t->data = A[i];
        t->next = NULL;
        last->next = t;
        last = t;
        
    }
}

void RemoveDup(struct Node *p){
    struct Node *q=p->next;
    
    while(q!=NULL){
        if(p->data != q->data){
            p=q;
            q=q->next;
        }
        else{
            p->next = q->next;
            free(q);
            q=p->next;
        }
    }
}

void Display(struct Node *p){
    while(p!=NULL){
        printf("%d ", p->data);
        p=p->next;
    }
    printf("\n");
}

int main(){
    
    int A[] = {10,20,20,20,30,40,50};
    create(A,7);
    RemoveDup(first);
    Display(first);
    printf("\n");
   
    return 0;
}
 

//reversing a LL

#include <stdio.h>
#include <stdlib.h>

struct Node{
    int data;
    struct Node *next;
}*first = NULL; //this is global that is it can be directly accessed or even pass it as parameter

void create(int A[], int n){
    int i;
    struct Node *t, *last;
    first = (struct Node *)malloc(sizeof(struct Node));
    first->data = A[0];
    first->next =NULL;
    last = first;
    
    for(i=1; i<n; i++){
        t=(struct Node *)malloc(sizeof(struct Node));
        t->data = A[i];
        t->next = NULL;
        last->next = t;
        last = t;
        
    }
}

void Display(struct Node *p){
    while(p!=NULL){
        printf("%d ", p->data);
        p=p->next;
    }
    printf("\n");
}

int count(struct Node *p){
    int l=0;
    while(p){
        l++;
        p=p->next;
    }
    return l;
}

void Reverse1(struct Node *p){
    int *A,i=0;
    struct Node *q=p;
    
    A=(int *)malloc(sizeof(int)*count(p));              //using array
    
    while(q!=NULL){
        A[i]=q->data;
        q=q->next;
        i++;
    }
    q=p;
    i--;
    
    while(q!=NULL){
        q->data=A[i];
        q=q->next;
        i--;
    }
}

void Reverse2(struct Node *p){
    struct Node *q=NULL,*r=NULL;
    while(p!=NULL){
        r=q;                                //using 3 pointers
        q=p;
        p=p->next;
        q->next=r;
    }
    first=q;
}

void Reverse3(struct Node *q, struct Node *p){
    if(p){
        Reverse3(p,p->next);
        p->next=q;                                      //using recursion
    }
    else
        first=q;
}

int main(){
    
    int A[] = {10,20,30,40,50};
    create(A,5);
   // Reverse1(first);
   // Reverse2(first);
    Reverse3(NULL,first);
    Display(first);
    printf("\n");
   
    return 0;
}
 

//Concatination and merging of 2 LL

#include <stdio.h>
#include <stdlib.h>

struct Node{
    int data;
    struct Node *next;
}*first = NULL,*second=NULL,*third=NULL; //this is global that is it can be directly accessed or even pass it as parameter

void create(int A[], int n){
    int i;
    struct Node *t, *last;
    first = (struct Node *)malloc(sizeof(struct Node));
    first->data = A[0];
    first->next =NULL;
    last = first;
    
    for(i=1; i<n; i++){
        t=(struct Node *)malloc(sizeof(struct Node));
        t->data = A[i];
        t->next = NULL;
        last->next = t;
        last = t;
        
    }
}

void create2(int A[], int n){
    int i;
    struct Node *t, *last;
    second = (struct Node *)malloc(sizeof(struct Node));
    second->data = A[0];
    second->next =NULL;
    last = second;
    
    for(i=1; i<n; i++){
        t=(struct Node *)malloc(sizeof(struct Node));
        t->data = A[i];
        t->next = NULL;
        last->next = t;
        last = t;
        
    }
}

void Display(struct Node *p){
    while(p!=NULL){
        printf("%d ", p->data);
        p=p->next;
    }
    printf("\n");
}

void Concat(struct Node *p, struct Node *q){
    third =p;
    
    while(p->next!=NULL){
        p=p->next;
    }
    p->next=q;
}

void Merge(struct Node *p, struct Node *q){
    struct Node *last;
    if(p->data < q->data){
        third=last=p;
        p=p->next;
        third->next=NULL;
    }
    else{
        third=last=q;
        q=q->next;
        third->next=NULL;
    }
    
    while(p && q){
        if(p->data < q->data){
            last->next=p;
            last=p;
            p=p->next;
            last->next=NULL;
        }
        else{
            last->next=q;
            last=q;
            q=q->next;
            last->next=NULL;
        }
    }
    
    if(p)last->next=p;
    if(q)last->next=q;
}

int main(){
    
    int A[] = {10,20,30,40,50};
    int B[] = {5,15,25,35,45};
    create(A,5);
    create2(B,5);
   
    printf("First\n");
    Display(first);
    printf("\n");
    
    printf("Second\n");
    Display(second);
    printf("\n");
   
//    Concat(second, first);
//    printf("Concatenated\n");
//    Display(third);
//    printf("\n");
    
    Merge(first, second);
    printf("Merged\n");
    Display(third);
    printf("\n");
    
    return 0;
}
 

//to check a loop in a LL

#include <stdio.h>
#include <stdlib.h>

struct Node{
    int data;
    struct Node *next;
}*first = NULL; //this is global that is it can be directly accessed or even pass it as parameter

void create(int A[], int n){
    int i;
    struct Node *t, *last;
    first = (struct Node *)malloc(sizeof(struct Node));
    first->data = A[0];
    first->next =NULL;
    last = first;
    
    for(i=1; i<n; i++){
        t=(struct Node *)malloc(sizeof(struct Node));
        t->data = A[i];
        t->next = NULL;
        last->next = t;
        last = t;
        
    }
}

int isLoop(struct Node *f){
    struct Node *p,*q;
    p=q=f;
    
    do{
        p=p->next;
        q=q->next;
        q=q?q->next:q;
    }while(p && q && p!=q);
    if(p==q)
        return 1;
    else
        return 0;
}

int main(){
    struct Node *t1,*t2;
    
    int A[] = {10,20,30,40,50};
    create(A,5);
   
    t1=first->next->next;    //t1 will point on 30
    t2=first->next->next->next->next;    //t1 will point on 50
    t2->next=t1;                //so this makes it a loop i.e from 50 it,ll point to 30
    
    printf("%d\n", isLoop(first));
    
    return 0;
}
 

//C++ class for LL

#include <iostream>
using namespace std;

class Node {
public:
    int data;
    Node* next;
};

class LinkedList {
private:
    Node* first;

public:
    LinkedList() { first = NULL; }
    LinkedList(int A[], int n);
    ~LinkedList();

    void Display();
    void Insert(int index, int x);
    int Delete(int index);
    int Length();
};

LinkedList::LinkedList(int A[], int n) {
    Node* last, * t;
    int i = 0;

    first = new Node;
    first->data = A[0];
    first->next = NULL;
    last = first;

    for (i = 1; i < n; i++) {
        t = new Node;
        t->data = A[i];
        t->next = NULL;
        last->next = t;
        last = t;
    }
}

LinkedList::~LinkedList() {
    Node* p = first;
    while (first) {
        first = first->next;
        delete p;
        p = first;
    }
}

void LinkedList::Display() {
    Node* p = first;
    while (p) {
        cout << p->data << " ";
        p = p->next;
    }
    cout << endl;
}

int LinkedList::Length() {
    Node* p = first;
    int len = 0;
    while (p) {
        len++;
        p = p->next;
    }
    return len;
}

void LinkedList::Insert(int index, int x) {
    Node* t, * p = first;
    if (index < 0 || index > Length())
        return;
    t = new Node;
    t->data = x;
    t->next = NULL;

    if (index == 0) {
        t->next = first;
        first = t;
    } else {
        for (int i = 0; i < index - 1; i++)
            p = p->next;
        t->next = p->next;
        p->next = t;
    }
}

int LinkedList::Delete(int index) {
    Node* p, * q = NULL;
    int x = -1;
    if (index < 1 || index > Length())
        return -1;
    if (index == 1) {
        p = first;
        first = first->next;
        x = p->data;
        delete p;
    } else {
        p = first;
        for (int i = 0; i < index - 1; i++) {
            q = p;
            p = p->next;
        }
        q->next = p->next;
        x = p->data;
        delete p;
    }
    return x;
}

int main() {
    int A[] = { 1, 2, 3, 4, 5 };
    LinkedList l(A, 5);
    l.Insert(3, 10);
    l.Display();
    return 0;
}

 
//circular LL

#include <stdio.h>
#include <stdlib.h>

struct Node{
    int data;
    struct Node *next;
}*Head;

void create(int A[], int n){
    int i;
    struct Node *t,*last;
    Head = (struct Node*)malloc(sizeof(struct Node));
    Head->data =A[0];
    Head->next=Head;
    last = Head;
    
    for(i=1; i<n; i++){
        t=(struct Node*)malloc(sizeof(struct Node));
        t->data = A[i];
        t->next = last->next;
        last->next = t;
        last = t;
    }
}

void Display(struct Node *h){
    do{
        printf("%d ",h->data);
        h=h->next;
    }while(h!=Head);
    printf("\n");
}

void RDisplay(struct Node *h){
    static int flag = 0;
    if(h!=Head || flag==0){
        flag = 1;
        printf("%d ",h->data);
        RDisplay(h->next);
    }
    flag = 0;
}

int main(){
    int A[] = {2,3,4,5,6};
    create(A, 5);
    //Display(Head);
    RDisplay(Head);
    return 0;
}
 


//inserting in a circular LL

#include <stdio.h>
#include <stdlib.h>

struct Node{
    int data;
    struct Node *next;
}*Head;

void create(int A[], int n){
    int i;
    struct Node *t,*last;
    Head = (struct Node*)malloc(sizeof(struct Node));
    Head->data =A[0];
    Head->next=Head;
    last = Head;
    
    for(i=1; i<n; i++){
        t=(struct Node*)malloc(sizeof(struct Node));
        t->data = A[i];
        t->next = last->next;
        last->next = t;
        last = t;
    }
}

void Display(struct Node *h){
    do{
        printf("%d ",h->data);
        h=h->next;
    }while(h!=Head);
    printf("\n");
}

int Length(struct Node *p){
    int len=0;
    do{
        len++;
        p=p->next;
    }while(p!=Head);
    return len;
}

void Insert(struct Node *p, int index, int x){
    struct Node *t;
    int i;
    
    if(index<0 || index > Length(p))
        return;
    
    if(index==0){
        t=(struct Node *)malloc(sizeof(struct Node));
        t->data = x;
        if(Head==NULL){
            Head = t;
            Head->next=Head;
        }
        else{
            while(p->next!=Head)p=p->next;
            p->next=t;
            t->next=Head;
            Head=t;
        }
    }
    else{
        for(i=0; i<index-1; i++)p=p->next;
        t=(struct Node *)malloc(sizeof(struct Node));
        t->data=x;
        t->next=p->next;
        p->next = t;
    }
}

int main(){
    int A[] = {2,3,4,5,6};
    create(A, 5);
    
    Insert(Head, 2, 10);
    
    Display(Head);
    return 0;
}



//delete in a circular LL

#include <stdio.h>
#include <stdlib.h>

struct Node{
    int data;
    struct Node *next;
}*Head;

void create(int A[], int n){
    int i;
    struct Node *t,*last;
    Head = (struct Node*)malloc(sizeof(struct Node));
    Head->data =A[0];
    Head->next=Head;
    last = Head;
    
    for(i=1; i<n; i++){
        t=(struct Node*)malloc(sizeof(struct Node));
        t->data = A[i];
        t->next = last->next;
        last->next = t;
        last = t;
    }
}

void Display(struct Node *h){
    do{
        printf("%d ",h->data);
        h=h->next;
    }while(h!=Head);
    printf("\n");
}

int Length(struct Node *p){
    int len=0;
    do{
        len++;
        p=p->next;
    }while(p!=Head);
    return len;
}

int Delete(struct Node *p, int index){
    struct Node *q;
    int i,x;
    
    if(index<0 || index > Length(Head))
        return -1;
    if(index==1){
        while(p->next!=Head)p=p->next;
        x=Head->data;
        if(Head==p){
            free(Head);
            Head=NULL;
        }
        else{
            p->next=Head->next;
            free(Head);
            Head=p->next;
        }
    }
    else{
        for(i=0; i<index-2; i++)
            p=p->next;
        q=p->next;
        p->next=q->next;
        x=q->data;
        free(q);
    }
    return x;
}

int main(){
    int A[] = {2,3,4,5,6};
    create(A, 5);
    
    Delete(Head, 1);
    
    Display(Head);
    return 0;
}
 

//Doubly LL

#include <stdio.h>
#include <stdlib.h>

struct Node{
    struct Node *prev;
    int data;
    struct Node *next;
}*first=NULL;

void create(int A[], int n){
    struct Node *t, *last;
    int i;
    
    first=(struct Node *)malloc(sizeof(struct Node));
    first->data=A[0];
    first->prev=first->next=NULL;
    last=first;
    
    for(i=1; i<n; i++){
        t=(struct Node *)malloc(sizeof(struct Node));
        t->data=A[i];
        t->next=last->next;
        t->prev=last;
        last->next=t;
        last=t;
         
    }
}

void Display(struct Node *p){
    while(p){
        printf("%d ", p->data);
        p=p->next;
    }
    printf("\n");
}

int Length(struct Node *p){
    int len=0;
    
    while(p){
        len++;
        p=p->next;
    }
    return len;
}

int main(){
    int A[] = {10,20,30,40,50};
    create(A, 5);
    
    printf("\nLength is : %d\n", Length(first));
    
    Display(first);
    
    return 0;
}



//inserting in a doubly LL

#include <stdio.h>
#include <stdlib.h>

struct Node{
    struct Node *prev;
    int data;
    struct Node *next;
}*first=NULL;

void create(int A[], int n){
    struct Node *t, *last;
    int i;
    
    first=(struct Node *)malloc(sizeof(struct Node));
    first->data=A[0];
    first->prev=first->next=NULL;
    last=first;
    
    for(i=1; i<n; i++){
        t=(struct Node *)malloc(sizeof(struct Node));
        t->data=A[i];
        t->next=last->next;
        t->prev=last;
        last->next=t;
        last=t;
         
    }
}

void Display(struct Node *p){
    while(p){
        printf("%d ", p->data);
        p=p->next;
    }
    printf("\n");
}

int Length(struct Node *p){
    int len=0;
    
    while(p){
        len++;
        p=p->next;
    }
    return len;
}

void Insert (struct Node *p, int index, int x){
    struct Node *t;
    int i;
    if(index<0 || index > Length(p))
        return;
    if(index==0){
        t=(struct Node *)malloc(sizeof(struct Node));
        t->data=x;
        t->prev = NULL;
        t->next=first;
        first->prev=t;
        first=t;
    }
    else{
        for(i=0; i<index-1; i++)
            p=p->next;
        t=(struct Node *)malloc(sizeof(struct Node));
        t->data=x;
        
        t->prev=p;
        t->next=p->next;
        
        if(p->next)p->next->prev=t;
        p->next=t;
    }
}

int main(){
    int A[] = {10,20,30,40,50};
    create(A, 5);
    
    Insert(first, 2, 25);
    printf("\nLength is : %d\n", Length(first));
    
    Display(first);
    
    return 0;
}
 


//deleting in a doubly LL

#include <stdio.h>
#include <stdlib.h>

struct Node{
    struct Node *prev;
    int data;
    struct Node *next;
}*first=NULL;

void create(int A[], int n){
    struct Node *t, *last;
    int i;
    
    first=(struct Node *)malloc(sizeof(struct Node));
    first->data=A[0];
    first->prev=first->next=NULL;
    last=first;
    
    for(i=1; i<n; i++){
        t=(struct Node *)malloc(sizeof(struct Node));
        t->data=A[i];
        t->next=last->next;
        t->prev=last;
        last->next=t;
        last=t;
         
    }
}

void Display(struct Node *p){
    while(p){
        printf("%d ", p->data);
        p=p->next;
    }
    printf("\n");
}

int Length(struct Node *p){
    int len=0;
    
    while(p){
        len++;
        p=p->next;
    }
    return len;
}

int Delete(struct Node *p, int index){
    int x = -1, i;
    
    if(index<1 || index>Length(p))
        return -1;
    
    if(index==1){
        first=first->next;
        if(first)first->prev=NULL;
        
        x=p->data;
        free(p);
    }
    else{
        for(i=0; i<index-1; i++)
            p=p->next;
        p->prev->next=p->prev;
        if(p->next)
            p->next->prev=p->prev;
        x=p->data;
        free(p);
    }
    return x;
}

int main(){
    int A[] = {10,20,30,40,50};
    create(A, 5);
    
    Delete(first, 1);
    printf("\nLength is : %d\n", Length(first));
    
    Display(first);
    
    return 0;
}
 


// reverse a doubly LL

#include <stdio.h>
#include <stdlib.h>

struct Node{
    struct Node *prev;
    int data;
    struct Node *next;
}*first=NULL;

void create(int A[], int n){
    struct Node *t, *last;
    int i;
    
    first=(struct Node *)malloc(sizeof(struct Node));
    first->data=A[0];
    first->prev=first->next=NULL;
    last=first;
    
    for(i=1; i<n; i++){
        t=(struct Node *)malloc(sizeof(struct Node));
        t->data=A[i];
        t->next=last->next;
        t->prev=last;
        last->next=t;
        last=t;
         
    }
}

void Display(struct Node *p){
    while(p){
        printf("%d ", p->data);
        p=p->next;
    }
    printf("\n");
}

int Length(struct Node *p){
    int len=0;
    
    while(p){
        len++;
        p=p->next;
    }
    return len;
}

void Reverse(struct Node *p){
    struct Node *temp;
    
    while(p!=NULL){
        temp=p->next;
        p->next=p->prev;
        p->prev=temp;
        p=p->prev;
        if(p!=NULL && p->next==NULL)
            first=p;
    }
}

int main(){
    int A[] = {10,20,30,40,50};
    create(A, 5);
    
    Reverse(first);
    Display(first);
    
    return 0;
}
 


//polynomial using LL

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

struct Node {
    int coeff;
    int exp;
    struct Node *next;
} *poly = NULL;

void create() {
    struct Node *t, *last = NULL;
    int num, i;

    printf("Enter number of terms: ");
    scanf("%d", &num);
    printf("Enter each term with coeff and exp:\n");

    for (i = 0; i < num; i++) {
        t = (struct Node *)malloc(sizeof(struct Node));
        scanf("%d%d", &t->coeff, &t->exp);
        t->next = NULL;
        if (poly == NULL) {
            poly = last = t;
        } else {
            last->next = t;
            last = t;
        }
    }
}

void Display(struct Node *p) {
    while (p) {
        printf("%dx%d ", p->coeff, p->exp);
        if (p->next != NULL) {
            printf("+ ");
        }
        p = p->next;
    }
    printf("\n");
}

long Eval(struct Node *p, int x) {
    long val = 0;

    while (p) {
        val += p->coeff * pow(x, p->exp);
        p = p->next;
    }
    return val;
}

int main() {
    create();
    Display(poly);
    printf("Result when x = 1: %ld\n", Eval(poly, 1));
    return 0;
}
 


//Stack
//using array

#include <stdio.h>
#include <stdlib.h>

struct Stack{
    int size;
    int top;
    int *S;
};

void create(struct Stack *st){
    printf("Enter size : ");
    scanf("%d", &st->size);
    st->top=-1;
    st->S=(int *)malloc(st->size*sizeof(int));
}

void Display(struct Stack st){
    int i,top=st.top;
    for(i=top;i>=0;i--)
        printf("%d ",st.S[i]);
    printf("\n");
}

void push(struct Stack *st, int x){
    if(st->top==st->size-1)
        printf("Stack Overflow!!\n");
    else{
        st->top++;
        st->S[st->top]=x;
    }
}

int pop(struct Stack *st){
    int x=-1;
    if(st->top==-1)
        printf("Stack Underflow!!\n");
    else{
        x=st->S[st->top--];
    }
    return x;
}

int peek(struct Stack st, int index){
    int x=-1;
    if(st.top-index+1<0)
        printf("Invalid Index\n");
    x=st.S[st.top-index+1];
    return x;
}

int isEmpty(struct Stack st){
    if(st.top==-1)
        return 1;
    return 0;
}

int isFull(struct Stack st){
    return st.top==st.size-1;
}

int StackTop(struct Stack st){
    if(!isEmpty(st))
        return st.S[st.top];
    return -1;
}



int main(){
    struct Stack st;
    create(&st);
    
    push(&st, 10);
    push(&st, 20);
    push(&st, 30);
    push(&st, 40);
//    push(&st, 50);
//    push(&st, 60);
   // printf("%d \n",pop(&st));
    
    printf("%d \n",peek(st, 1));
    Display(st);
    return 0;
}

//stack using cpp

#include <iostream>
using namespace std;

template<class T>
class Stack
{
private:
    T *st;
    int size;
    int top;

public:
    Stack() {
        size = 10;
        top = -1;
        st = new T[size];
    }

    Stack(int size) {
        this->size = size;
        top = -1;
        st = new T[this->size];
    }

    void push(T x);
    T pop();
    T peek(int index);
    int stacktop();
    int isEmpty();
    int isFull();
    void Display();
};

template<class T>
void Stack<T>::push(T x) {
    if (isFull())
        cout << "Stack Overflow" << endl;
    else {
        top++;
        st[top] = x;
    }
}

template<class T>
T Stack<T>::pop() {
    T x = -1;
    if (isEmpty())
        cout << "Stack underflow" << endl;
    else {
        x = st[top];
        top--;
    }
    return x;
}

template<class T>
T Stack<T>::peek(int index) {
    T x = -1;
    if (top - index + 1 < 0)
        cout << "Invalid Index" << endl;
    else
        x = st[top - index + 1];

    return x;
}

template<class T>
int Stack<T>::stacktop() {
    if (isEmpty())
        return -1;
    return st[top];
}

template<class T>
int Stack<T>::isFull() {
    return top == size - 1;
}

template<class T>
int Stack<T>::isEmpty() {
    return top == -1;
}

template<class T>
void Stack<T>::Display() {
    for (int i = top; i >= 0; i--)
        cout << st[i] << " ";
    cout << endl;
}

int main() {
    Stack<char> stk(5);
    stk.push('a');
    stk.push('b');
    stk.push('c');
    stk.push('d');
    stk.push('e');
    stk.push('f');
    
    stk.Display();
    
    cout << stk.peek(1) << endl;

    return 0;
}
 
 
//stack using LL

#include <stdio.h>
#include <stdlib.h>

struct Node{
    int data;
    struct Node *next;
}*top=NULL;

void Push(int x){
    struct Node *t;
    t=(struct Node*)malloc(sizeof(struct Node));
    
    if(t==NULL)
        printf("Stsck is Full\n");
    else{
        t->data=x;
        t->next=top;
        top=t;
    }
}

int Pop(){
    struct Node *t;
    int x=-1;
    
    if(top==NULL)
        printf("Stack is Empty\n");
    else{
        t=top;
        top=top->next;
        x=t->data;
        free(t);
    }
    return x;
}

void Display(){
    struct Node *p;
    p=top;
    while(p!=NULL){
        printf("%d ",p->data);
        p=p->next;
    }
    printf("\n");
}

int main(){
    
    Push(10);
    Push(20);
    Push(30);
    
    Display();
    
    printf("%d\n", Pop());
    return 0;
}


//stack using LL in C++

#include <iostream>

using namespace std;

class Node {
public:
    int data;
    Node *next;
};

class Stack {
private:
    Node *top;

public:
    Stack() {
        top = NULL;
    }

    void push(int x);
    int pop();
    void Display();
};

void Stack::push(int x) {
    Node *t = new Node;
    if (t == NULL)
        cout << "Stack is Full\n";
    else {
        t->data = x;
        t->next = top;
        top = t;
    }
}

int Stack::pop() {
    int x = -1;
    if (top == NULL)
        cout << "Stack is Empty\n";
    else {
        x = top->data;
        Node *t = top;
        top = top->next;
        delete t;
    }
    return x;
}

void Stack::Display() {
    Node *p = top;
    while (p != NULL) {
        cout << p->data << " ";
        p = p->next;
    }
    cout << endl;
}

int main() {
    Stack stk;

    stk.push(10);
    stk.push(20);
    stk.push(30);

    stk.Display();
    cout << stk.pop();

    return 0;
}
 

//parenthesis matching

#include <stdio.h>
#include <stdlib.h>

struct Node{
    char data;
    struct Node *next;
}*top=NULL;

void Push(char x){
    struct Node *t;
    t=(struct Node*)malloc(sizeof(struct Node));
    
    if(t==NULL)
        printf("Stsck is Full\n");
    else{
        t->data=x;
        t->next=top;
        top=t;
    }
}

char Pop(){
    struct Node *t;
    char x=-1;
    
    if(top==NULL)
        printf("Stack is Empty\n");
    else{
        t=top;
        top=top->next;
        x=t->data;
        free(t);
    }
    return x;
}

void Display(){
    struct Node *p;
    p=top;
    while(p!=NULL){
        printf("%d ",p->data);
        p=p->next;
    }
    printf("\n");
}

int isBalanced(char *exp){
    int i;
    
    for(i=0; exp[i]!='\0'; i++){
        if(exp[i]=='(')
            Push(exp[i]);
        else if (exp[i]==')'){
            if(top==NULL)
                return 0;
            Pop();
        }
    }
    if(top==NULL)
        return 1;
    else
        return 0;
}

int main(){
    
    char *exp = "((a+b)*(c-d))";
    
    printf("%d ",isBalanced(exp));
    return 0;
}


//infix to postfix

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node{
    char data;
    struct Node *next;
}*top=NULL;

void Push(char x){
    struct Node *t;
    t=(struct Node*)malloc(sizeof(struct Node));
    
    if(t==NULL)
        printf("Stack is Full\n");
    else{
        t->data=x;
        t->next=top;
        top=t;
    }
}

char Pop(){
    struct Node *t;
    char x=-1;
    
    if(top==NULL)
        printf("Stack is Empty\n");
    else{
        t=top;
        top=top->next;
        x=t->data;
        free(t);
    }
    return x;
}

void Display(){
    struct Node *p;
    p=top;
    while(p!=NULL){
        printf("%d ",p->data);
        p=p->next;
    }
    printf("\n");
}

int precedence(char x){
    if(x=='+' || x=='-')
        return 1;
    else if (x=='*' || x=='/')
        return 2;
    return 0;
}

int isOperand(char x){
    if(x=='+' || x=='-' || x=='*' || x=='/')
        return 0;
    else
        return 1;
}

char * InToPost(char *infix){
    int i=0,j=0;
    
    char *postfix;
    long len=strlen(infix);
    postfix=(char *)malloc((len+2)*sizeof(char));
    
    while(infix[i]!='\0'){
        if(isOperand(infix[i]))
            postfix[j++]=infix[i++];
        else{
            if(precedence(infix[i])>precedence(top->data))
                Push(infix[i++]);
            else{
                postfix[j++]=Pop();
            }
        }
    }
    while(top!=NULL)
        postfix[j++]=Pop();
    postfix[j]='\0';
    return postfix;
}

int main(){
    char *infix="a+b*c-d/e";
    
    Push('#');
    char *postfix=InToPost(infix);
    printf("%s \n",postfix);
    return 0;
}

//evaluation of postfix

#include <stdio.h>
#include <stdlib.h>
#include <strings.h>

struct Node {
    int data;
    struct Node *next;
} *top = NULL;

void push(int x) {
    struct Node *t;
    t = (struct Node *)malloc(sizeof(struct Node));

    if (t == NULL)
        printf("Stack is full\n");
    else {
        t->data = x;
        t->next = top;
        top = t;
    }
}

int pop() {
    struct Node *t;
    int x = -1;

    if (top == NULL)
        printf("Stack is Empty\n");
    else {
        t = top;
        top = top->next;
        x = t->data;
        free(t);
    }
    return x;
}

void Display() {
    struct Node *p;
    p = top;
    while (p != NULL) {
        printf("%d ", p->data);
        p = p->next;
    }
    printf("\n");
}

int isBalanced(char *exp) {
    int i;

    for (i = 0; exp[i] != '\0'; i++) {
        if (exp[i] == '(')
            push(exp[i]);
        else if (exp[i] == ')') {
            if (top == NULL)
                return 0;
            pop();
        }
    }
    if (top == NULL)
        return 1;
    else
        return 0;
}

int pre(char x) {
    if (x == '+' || x == '-')
        return 1;
    else if (x == '*' || x == '/')
        return 2;
    return 0;
}

int isOperand(char x) {
    if (x == '+' || x == '-' || x == '*' || x == '/')
        return 0;
    else
        return 1;
}

char *InToPost(char *infix) {
    int i = 0, j = 0;
    char *postfix;
    long len = strlen(infix);
    postfix = (char *)malloc((len + 2) * sizeof(char));

    while (infix[i] != '\0') {
        if (isOperand(infix[i]))
            postfix[j++] = infix[i++];
        else {
            if (pre(infix[i]) > pre(top->data))
                push(infix[i++]);
            else {
                postfix[j++] = pop();
            }
        }
    }
    while (top != NULL)
        postfix[j++] = pop();
    postfix[j] = '\0';
    return postfix;
}

int Eval(char *postfix) {
    int i = 0;
    int x1, x2, r = 0;

    for (i = 0; postfix[i] != '\0'; i++) {
        if (isOperand(postfix[i])) {
            push(postfix[i] - '0');
        } else {
            x2 = pop();
            x1 = pop();
            switch (postfix[i]) {
                case '+':
                    r = x1 + x2;
                    break;
                case '-':
                    r = x1 - x2;
                    break;
                case '*':
                    r = x1 * x2;
                    break;
                case '/':
                    r = x1 / x2;
                    break;
            }
            push(r);
        }
    }
    return top->data;
}

int main() {
    char *postfix = "234*+82/-";

    printf("Result is %d\n", Eval(postfix));

    return 0;
}

//Queues
//Queues using Array

#include <stdio.h>
#include <stdlib.h>

struct Queue{
    int size;
    int front;
    int rear;
    int *Q;
    
};

void create(struct Queue *q, int size){
    q->size=size;
    q->front=q->rear=-1;
    q->Q=(int *)malloc(q->size*sizeof(int));
}

void enqueue(struct Queue *q,int x){
    if(q->rear==q->size-1)
        printf("Queue is Full");
    else{
        q->rear++;
        q->Q[q->rear]=x;
    }
}

int dequeue(struct Queue *q){
    int x=-1;
    
    if(q->front==q->rear)
        printf("Queue is Empty\n");
    else{
        q->front++;
        x=q->Q[q->front];
    }
    return x;
}

void Display(struct Queue q){
    int i;
    for(i=q.front+1; i<=q.rear; i++)
        printf("%d ",q.Q[i]);
    printf("\n");
}

int main(){
    struct Queue q;
    create(&q, 5);
    
    enqueue(&q, 10);
    enqueue(&q, 20);
    enqueue(&q, 30);
    printf("%d\n", dequeue(&q));
    Display(q);
    
    return 0;
}

//Queue in C++

#include <iostream>
using namespace std;

class Queue{
private:
    int front;
    int rear;
    int size;
    int *Q;
public:
    Queue(){front=rear=-1;size=10;Q=new int[size];}
    Queue(int size){front=rear=-1;this->size=size;Q=new int[this->size];}
    void enqueue(int x);
    int dequeue();
    void Display();
};

void Queue::enqueue(int x){
    if(rear==size-1)
        printf("Queue is Full\n");
    else{
        rear++;
        Q[rear]=x;
    }
}

int Queue::dequeue(){
    int x=-1;
    if(front==rear)
        printf("Queue is Empty\n");
    else{
        x=Q[front+1];
        front++;
    }
    return x;
}

void Queue::Display(){
    for(int i=front+1; i<=rear; i++)
        printf("%d ",Q[i]);
    printf("\n");
}

int main(){
    Queue q(5);
    
    q.enqueue(10);
    q.enqueue(20);
    q.enqueue(30);
    
    q.Display();
    return 0;
}

//circular queue

#include <stdio.h>
#include <stdlib.h>

struct Queue{
    int size;
    int front;
    int rear;
    int *Q;
    
};

void create(struct Queue *q, int size){
    q->size=size;
    q->front=q->rear=0;
    q->Q=(int *)malloc(q->size*sizeof(int));
}

void enqueue(struct Queue *q,int x){
    if((q->rear+1)%q->size==q->front)
        printf("Queue is Full");
    else{
        q->rear=(q->rear+1)%q->size;
        q->Q[q->rear]=x;
    }
}

int dequeue(struct Queue *q){
    int x=-1;
    
    if(q->front==q->rear)
        printf("Queue is Empty\n");
    else{
        q->front=(q->front+1)%q->size;
        x=q->Q[q->front];
    }
    return x;
}

void Display(struct Queue q){
    int i=q.front+1;
    
    do{
        printf("%d ",q.Q[i]);
        i=(i+1)%q.size;
    }while(i!=(q.rear+1)%q.size);
    
    printf("\n");
}

int main(){
    struct Queue q;
    create(&q, 5);
    
    enqueue(&q, 10);
    enqueue(&q, 20);
    enqueue(&q, 30);
    enqueue(&q, 40);
    enqueue(&q, 50);
    enqueue(&q, 60);
    Display(q);
    
    return 0;
}

//queue using LL

#include <stdio.h>
#include <stdlib.h>

struct Node{
    int data;
    struct Node *next;
}*front=NULL,*rear=NULL;

void enqueue(int x){
    struct Node *t;
    t=(struct Node *)malloc(sizeof(struct Node));
    if(t==NULL)
        printf("Queue is Full\n");
    else{
        t->data=x;
        t->next=NULL;
        if(front==NULL)
            front=rear=t;
        else{
            rear->next=t;
            rear=t;
        }
    }
}

int dequeue(){
    int x=-1;
    struct Node *t;
    
    if(front==NULL)
        printf("Queue is Empty\n");
    else{
        x=front->data;
        t=front;
        front=front->next;
        free(t);
    }
    return x;
}

void Display(){
    struct Node *p=front;
    while(p){
        printf("%d ",p->data);
        p=p->next;
    }
    printf("\n");
}

int main(){
    enqueue(10);
    enqueue(20);
    enqueue(30);
    enqueue(40);
    enqueue(50);
    enqueue(60);
    
    Display();
    
    return 0;
}

//Binary tree

#include <stdio.h>
#include <stdlib.h>

struct Node{
    struct Node *lchild;
    int data;
    struct Node *rchild;
};

struct Queue{
    int size;
    int front;
    int rear;
    Node **Q;
    
};

void create(struct Queue *q, int size){
    q->size=size;
    q->front=q->rear=0;
    q->Q=(Node **)malloc(q->size*sizeof(Node *));
}

void enqueue(struct Queue *q,Node *x){
    if((q->rear+1)%q->size==q->front)
        printf("Queue is Full");
    else{
        q->rear=(q->rear+1)%q->size;
        q->Q[q->rear]=x;
    }
}

Node * dequeue(struct Queue *q){
    Node * x=NULL;
    
    if(q->front==q->rear)
        printf("Queue is Empty\n");
    else{
        q->front=(q->front+1)%q->size;
        x=q->Q[q->front];
    }
    return x;
}

int isEmpty(struct Queue q){
    return q.front==q.rear;
}

struct Node *root=NULL;

void Treecreate(){
    struct Node *p, *t;
    int x;
    struct Queue q;
    create(&q, 100);
    
    printf("Enter root value : ");
    scanf("%d",&x);
    root=(struct Node *)malloc(sizeof(struct Node));
    root->data=x;
    root->lchild=root->rchild=NULL;
    enqueue(&q, root);
    
    while(!isEmpty(q)){
        p=dequeue(&q);
        printf("Enter left child of %d : ",p->data);
        scanf("%d",&x);
        if(x!=-1){
            t=(struct Node *)malloc(sizeof(struct Node));
            t->data=x;
            t->lchild=t->rchild=NULL;
            p->lchild=t;
            enqueue(&q, t);
        }
        printf("Enter right child of %d : ",p->data);
        scanf("%d",&x);
        if(x!=-1){
            t=(struct Node *)malloc(sizeof(struct Node));
            t->data=x;
            t->lchild=t->rchild=NULL;
            p->rchild=t;
            enqueue(&q, t);
        }
    }
}

void preorder(struct Node *p){
    if(p){
        printf("%d ",p->data);
        preorder(p->lchild);
        preorder(p->rchild);
    }
}

void Inorder(struct Node *p){
    if(p){
        Inorder(p->lchild);
        printf("%d ",p->data);
        Inorder(p->rchild);
    }
}

void postorder(struct Node *p){
    if(p){
        postorder(p->lchild);
        postorder(p->rchild);
        printf("%d ",p->data);
    }
}
 

int main(){
    Treecreate();
    preorder(root);
    printf("\nPost Order : ");
    postorder(root);
    return 0;
}


//creating Binary tree in C++

#include <iostream>
#include <stdio.h>
using namespace std;

class Node{
public:
    Node *lchild;
    int data;
    Node *rchild;
};

class Queue{
private:
    int front;
    int rear;
    int size;
    Node **Q;
public:
    Queue(){front=rear=-1;size=10;Q=new Node*[size];}
    Queue(int size){front=rear=-1;this->size=size;Q=new Node*[this->size];}
    void enqueue(Node * x);
    Node * dequeue();
    int isEmpty(){return front==rear;}
    void Display();
};

void Queue::enqueue(Node * x){
    if(rear==size-1)
        printf("Queue is Full\n");
    else{
        rear++;
        Q[rear]=x;
    }
}

Node * Queue::dequeue(){
    Node * x=NULL;
    if(front==rear)
        printf("Queue is Empty\n");
    else{
        x=Q[front+1];
        front++;
    }
    return x;
}

void Queue::Display(){
    for(int i=front+1; i<=rear; i++)
        printf("%d ",Q[i]);
    printf("\n");
}

class Tree {
    
public:
    Node *root;
    Tree() { root = NULL; }
    void CreateTree();
    void Preorder() { Preorder(root); }
    void Preorder(Node *p);
    void Postorder() { Postorder(root); }
    void Postorder(Node *p);
    void Inorder() { Inorder(root); }
    void Inorder(Node *p);
    void Levelorder() { Levelorder(root); }
    void Levelorder(Node *p);
    int Height() { return Height(root); }
    int Height(Node *root);
};

void Tree::CreateTree() {
    Node *p, *t;
    int x;
    Queue q(100);
    
    printf("Enter root value: ");
    scanf("%d", &x);
    root = new Node;
    root->data = x;
    root->lchild = root->rchild = NULL;
    q.enqueue(root);
    
    while (!q.isEmpty()) {
        p = q.dequeue();
        
        printf("Enter left child of %d: ", p->data);
        scanf("%d", &x);
        if (x != -1) {
            t = new Node;
            t->data = x;
            t->lchild = t->rchild = NULL;
            p->lchild = t;
            q.enqueue(t);
        }
        
        printf("Enter right child of %d: ", p->data);
        scanf("%d", &x);
        if (x != -1) {
            t = new Node;
            t->data = x;
            t->lchild = t->rchild = NULL;
            p->rchild = t;
            q.enqueue(t);
        }
    }
}

void Tree::Preorder(struct Node *p) {
    if (p) {
        printf("%d ", p->data);
        Preorder(p->lchild);
        Preorder(p->rchild);
    }
}

void Tree::Inorder(struct Node *p) {
    if (p) {
        Inorder(p->lchild);
        printf("%d ", p->data);
        Inorder(p->rchild);
    }
}

void Tree::Postorder(struct Node *p) {
    if (p) {
        Postorder(p->lchild);
        Postorder(p->rchild);
        printf("%d ", p->data);
    }
}

void Tree::Levelorder(struct Node *root) {
    Queue q(100);
    
    printf("%d ", root->data);
    q.enqueue(root);
    
    while (!q.isEmpty()) {
        root = q.dequeue();
        
        if (root->lchild) {
            printf("%d ", root->lchild->data);
            q.enqueue(root->lchild);
        }
        
        if (root->rchild) {
            printf("%d ", root->rchild->data);
            q.enqueue(root->rchild);
        }
    }
}

int Tree::Height(struct Node *root) {
    int x = 0, y = 0;
    
    if (root == 0)
        return 0;
    
    x = Height(root->lchild);
    y = Height(root->rchild);
    
    if (x > y)
        return x + 1;
    else
        return y + 1;
}

int main() {
    Tree t;
    t.CreateTree();
    cout << "Preorder: ";
    t.Preorder();
    cout << endl;
    cout << "Inorder: ";
    t.Inorder();
    cout << endl << endl;
    
    return 0;
}

//iterative traversals

#include <stdio.h>
#include <stdlib.h>

struct Stack{
    int size;
    int top;
    struct Node **S;
};

void Stackcreate(struct Stack *st, int size){
    st->size=size;
    st->top=-1;
    st->S=(struct Node **)malloc(st->size*sizeof(struct Node *));
}


void push(struct Stack *st, struct Node * x){
    if(st->top==st->size-1)
        printf("Stack Overflow!!\n");
    else{
        st->top++;
        st->S[st->top]=x;
    }
}

struct Node * pop(struct Stack *st){
    struct Node * x=NULL;
    if(st->top==-1)
        printf("Stack Underflow!!\n");
    else{
        x=st->S[st->top--];
    }
    return x;
}

int isEmpty(struct Stack st){
    if(st.top==-1)
        return 1;
    return 0;
}

int isFull(struct Stack st){
    return st.top==st.size-1;
}


struct Node{
    struct Node *lchild;
    int data;
    struct Node *rchild;
};

struct Queue{
    int size;
    int front;
    int rear;
    Node **Q;
    
};

void create(struct Queue *q, int size){
    q->size=size;
    q->front=q->rear=0;
    q->Q=(Node **)malloc(q->size*sizeof(Node *));
}

void enqueue(struct Queue *q,Node *x){
    if((q->rear+1)%q->size==q->front)
        printf("Queue is Full");
    else{
        q->rear=(q->rear+1)%q->size;
        q->Q[q->rear]=x;
    }
}

Node * dequeue(struct Queue *q){
    Node * x=NULL;
    
    if(q->front==q->rear)
        printf("Queue is Empty\n");
    else{
        q->front=(q->front+1)%q->size;
        x=q->Q[q->front];
    }
    return x;
}

int isEmpty(struct Queue q){
    return q.front==q.rear;
}

struct Node *root=NULL;

void Treecreate(){
    struct Node *p, *t;
    int x;
    struct Queue q;
    create(&q, 100);
    
    printf("Enter root value : ");
    scanf("%d",&x);
    root=(struct Node *)malloc(sizeof(struct Node));
    root->data=x;
    root->lchild=root->rchild=NULL;
    enqueue(&q, root);
    
    while(!isEmpty(q)){
        p=dequeue(&q);
        printf("Enter left child of %d : ",p->data);
        scanf("%d",&x);
        if(x!=-1){
            t=(struct Node *)malloc(sizeof(struct Node));
            t->data=x;
            t->lchild=t->rchild=NULL;
            p->lchild=t;
            enqueue(&q, t);
        }
        printf("Enter right child of %d : ",p->data);
        scanf("%d",&x);
        if(x!=-1){
            t=(struct Node *)malloc(sizeof(struct Node));
            t->data=x;
            t->lchild=t->rchild=NULL;
            p->rchild=t;
            enqueue(&q, t);
        }
    }
}

void preorder(struct Node *p){
    if(p){
        printf("%d ",p->data);
        preorder(p->lchild);
        preorder(p->rchild);
    }
}

void Inorder(struct Node *p){
    if(p){
        Inorder(p->lchild);
        printf("%d ",p->data);
        Inorder(p->rchild);
    }
}

void postorder(struct Node *p){
    if(p){
        postorder(p->lchild);
        postorder(p->rchild);
        printf("%d ",p->data);
    }
}

void Ipreorder(struct Node *p){
    struct Stack stk;
    Stackcreate(&stk, 100);
    
    while(p || !isEmpty(stk)){
        if(p){
            printf("%d ",p->data);
            push(&stk, p);
            p=p->lchild;
        }
        else{
            p=pop(&stk);
            p=p->rchild;
        }
    }
}

void Iinorder(struct Node *p){
    struct Stack stk;
    Stackcreate(&stk, 100);
    
    while(p || !isEmpty(stk)){
        if(p){
            push(&stk, p);
            p=p->lchild;
        }
        else{
            p=pop(&stk);
            printf("%d ",p->data);
            p=p->rchild;
        }
    }
}

int main(){
    Treecreate();
    
    printf("\nIn Order : ");
    Iinorder(root);
    return 0;
}

//level order traversal

#include <stdio.h>
#include <stdlib.h>

struct Stack{
    int size;
    int top;
    struct Node **S;
};

void Stackcreate(struct Stack *st, int size){
    st->size=size;
    st->top=-1;
    st->S=(struct Node **)malloc(st->size*sizeof(struct Node *));
}


void push(struct Stack *st, struct Node * x){
    if(st->top==st->size-1)
        printf("Stack Overflow!!\n");
    else{
        st->top++;
        st->S[st->top]=x;
    }
}

struct Node * pop(struct Stack *st){
    struct Node * x=NULL;
    if(st->top==-1)
        printf("Stack Underflow!!\n");
    else{
        x=st->S[st->top--];
    }
    return x;
}

int isEmpty(struct Stack st){
    if(st.top==-1)
        return 1;
    return 0;
}

int isFull(struct Stack st){
    return st.top==st.size-1;
}


struct Node{
    struct Node *lchild;
    int data;
    struct Node *rchild;
};

struct Queue{
    int size;
    int front;
    int rear;
    Node **Q;
    
};

void create(struct Queue *q, int size){
    q->size=size;
    q->front=q->rear=0;
    q->Q=(Node **)malloc(q->size*sizeof(Node *));
}

void enqueue(struct Queue *q,Node *x){
    if((q->rear+1)%q->size==q->front)
        printf("Queue is Full");
    else{
        q->rear=(q->rear+1)%q->size;
        q->Q[q->rear]=x;
    }
}

Node * dequeue(struct Queue *q){
    Node * x=NULL;
    
    if(q->front==q->rear)
        printf("Queue is Empty\n");
    else{
        q->front=(q->front+1)%q->size;
        x=q->Q[q->front];
    }
    return x;
}

int isEmpty(struct Queue q){
    return q.front==q.rear;
}

struct Node *root=NULL;

void Treecreate(){
    struct Node *p, *t;
    int x;
    struct Queue q;
    create(&q, 100);
    
    printf("Enter root value : ");
    scanf("%d",&x);
    root=(struct Node *)malloc(sizeof(struct Node));
    root->data=x;
    root->lchild=root->rchild=NULL;
    enqueue(&q, root);
    
    while(!isEmpty(q)){
        p=dequeue(&q);
        printf("Enter left child of %d : ",p->data);
        scanf("%d",&x);
        if(x!=-1){
            t=(struct Node *)malloc(sizeof(struct Node));
            t->data=x;
            t->lchild=t->rchild=NULL;
            p->lchild=t;
            enqueue(&q, t);
        }
        printf("Enter right child of %d : ",p->data);
        scanf("%d",&x);
        if(x!=-1){
            t=(struct Node *)malloc(sizeof(struct Node));
            t->data=x;
            t->lchild=t->rchild=NULL;
            p->rchild=t;
            enqueue(&q, t);
        }
    }
}


void LevelOrder(struct Node *root) {
    struct Queue q;
    create(&q, 100);
    
    printf("%d ", root->data);
    enqueue(&q, root);
    
    while (!isEmpty(q)) {
        root = dequeue(&q);
        
        if (root->lchild) {
            printf("%d ", root->lchild->data);
            enqueue(&q, root->lchild);
        }
        
        if (root->rchild) {
            printf("%d ", root->rchild->data);
            enqueue(&q, root->rchild);
        }
    }
}

int main() {
    Treecreate();
    LevelOrder(root);
    return 0;
}

//counting number of nodes and height of a Binary tree

#include <stdio.h>
#include <stdlib.h>

struct Stack{
    int size;
    int top;
    struct Node **S;
};

void Stackcreate(struct Stack *st, int size){
    st->size=size;
    st->top=-1;
    st->S=(struct Node **)malloc(st->size*sizeof(struct Node *));
}


void push(struct Stack *st, struct Node * x){
    if(st->top==st->size-1)
        printf("Stack Overflow!!\n");
    else{
        st->top++;
        st->S[st->top]=x;
    }
}

struct Node * pop(struct Stack *st){
    struct Node * x=NULL;
    if(st->top==-1)
        printf("Stack Underflow!!\n");
    else{
        x=st->S[st->top--];
    }
    return x;
}

int isEmpty(struct Stack st){
    if(st.top==-1)
        return 1;
    return 0;
}

int isFull(struct Stack st){
    return st.top==st.size-1;
}


struct Node{
    struct Node *lchild;
    int data;
    struct Node *rchild;
};

struct Queue{
    int size;
    int front;
    int rear;
    Node **Q;
    
};

void create(struct Queue *q, int size){
    q->size=size;
    q->front=q->rear=0;
    q->Q=(Node **)malloc(q->size*sizeof(Node *));
}

void enqueue(struct Queue *q,Node *x){
    if((q->rear+1)%q->size==q->front)
        printf("Queue is Full");
    else{
        q->rear=(q->rear+1)%q->size;
        q->Q[q->rear]=x;
    }
}

Node * dequeue(struct Queue *q){
    Node * x=NULL;
    
    if(q->front==q->rear)
        printf("Queue is Empty\n");
    else{
        q->front=(q->front+1)%q->size;
        x=q->Q[q->front];
    }
    return x;
}

int isEmpty(struct Queue q){
    return q.front==q.rear;
}

struct Node *root=NULL;

void Treecreate(){
    struct Node *p, *t;
    int x;
    struct Queue q;
    create(&q, 100);
    
    printf("Enter root value : ");
    scanf("%d",&x);
    root=(struct Node *)malloc(sizeof(struct Node));
    root->data=x;
    root->lchild=root->rchild=NULL;
    enqueue(&q, root);
    
    while(!isEmpty(q)){
        p=dequeue(&q);
        printf("Enter left child of %d : ",p->data);
        scanf("%d",&x);
        if(x!=-1){
            t=(struct Node *)malloc(sizeof(struct Node));
            t->data=x;
            t->lchild=t->rchild=NULL;
            p->lchild=t;
            enqueue(&q, t);
        }
        printf("Enter right child of %d : ",p->data);
        scanf("%d",&x);
        if(x!=-1){
            t=(struct Node *)malloc(sizeof(struct Node));
            t->data=x;
            t->lchild=t->rchild=NULL;
            p->rchild=t;
            enqueue(&q, t);
        }
    }
}

void postorder(struct Node *p){
    if(p){
        postorder(p->lchild);
        postorder(p->rchild);
        printf("%d ",p->data);
    }
}

void Ipreorder(struct Node *p){
    struct Stack stk;
    Stackcreate(&stk, 100);
    
    while(p || !isEmpty(stk)){
        if(p){
            printf("%d ",p->data);
            push(&stk, p);
            p=p->lchild;
        }
        else{
            p=pop(&stk);
            p=p->rchild;
        }
    }
}

void Iinorder(struct Node *p){
    struct Stack stk;
    Stackcreate(&stk, 100);
    
    while(p || !isEmpty(stk)){
        if(p){
            push(&stk, p);
            p=p->lchild;
        }
        else{
            p=pop(&stk);
            printf("%d ",p->data);
            p=p->rchild;
        }
    }
}

void LevelOrder(struct Node *root) {
    struct Queue q;
    create(&q, 100);
    
    printf("%d ", root->data);
    enqueue(&q, root);
    
    while (!isEmpty(q)) {
        root = dequeue(&q);
        
        if (root->lchild) {
            printf("%d ", root->lchild->data);
            enqueue(&q, root->lchild);
        }
        
        if (root->rchild) {
            printf("%d ", root->rchild->data);
            enqueue(&q, root->rchild);
        }
    }
}

int count(struct Node *root){
    if(root)
        return count(root->lchild)+count(root->rchild)+1;
    return 0;
}

int height(struct Node *root){
    int x=0,y=0;
    if(root==0)
        return 0;
    x=height(root->lchild);
    y=height(root->rchild);
    if(x>y)
        return x+1;
    else
        return y+1;
}

int main() {
    Treecreate();
    printf("Count %d : ",count(root));
    printf("Height %d : ",height(root));
    return 0;
}


//Binary Search Tree

#include <stdio.h>
#include <stdlib.h>

struct Node{
    struct Node *lchild;
    int data;
    struct Node *rchild;
}*root=NULL;

void Insert(int key){
    struct Node *t=root;
    struct Node *r,*p;
    
    if(root==NULL){
        p=(struct Node *)malloc(sizeof(struct Node));
        p->data=key;
        p->lchild=p->rchild=NULL;
        root=p;
        return;
    }
    while(t!=NULL){
        r=t;
        if(key<t->data)
            t=t->lchild;
        else if (key>t->data)
            t=t->rchild;
        else
            return;
    }
    p=(struct Node *)malloc(sizeof(struct Node));
    p->data=key;
    p->lchild=p->rchild=NULL;
    
    if(key<r->data) r->lchild=p;
    else r->rchild=p;
}

void Inorder(struct Node *p){
    if(p){
        Inorder(p->lchild);
        printf("%d ",p->data);
        Inorder(p->rchild);
    }
}

struct Node * Search(int key){
    struct Node *t=root;
    
    while(t!=NULL){
        if(key==t->data)
            return t;
        else if (key<t->data)
            t=t->lchild;
        else
            t=t->rchild;
    }
    return NULL;
}

int main(){
    struct Node *temp;
    
    Insert(10);
    Insert(5);
    Insert(20);
    Insert(8);
    Insert(30);
    
    Inorder(root);
    printf("\n");
    
    temp=Search(2);
    if(temp!=NULL)
        printf("Element %d is found\n",temp->data);
    else
        printf("element is not found\n");
    return 0;
}

//recursive insert and delete

#include <stdio.h>
#include <stdlib.h>

struct Node
{
    struct Node *lchild;
    int data;
    struct Node *rchild;
} *root = NULL;

void Insert(int key)
{
    struct Node *t = root;
    struct Node *r = NULL, *p;

    if (root == NULL)
    {
        p = (struct Node *)malloc(sizeof(struct Node));
        p->data = key;
        p->lchild = p->rchild = NULL;
        root = p;
        return;
    }
    while (t != NULL)
    {
        r = t;
        if (key < t->data)
            t = t->lchild;
        else if (key > t->data)
            t = t->rchild;
        else
            return;
    }
    p = (struct Node *)malloc(sizeof(struct Node));
    p->data = key;
    p->lchild = p->rchild = NULL;

    if (key < r->data)
        r->lchild = p;
    else
        r->rchild = p;
}

void Inorder(struct Node *p)
{
    if (p)
    {
        Inorder(p->lchild);
        printf("%d ", p->data);
        Inorder(p->rchild);
    }
}

struct Node *Search(int key)
{
    struct Node *t = root;

    while (t != NULL)
    {
        if (key == t->data)
            return t;
        else if (key < t->data)
            t = t->lchild;
        else
            t = t->rchild;
    }
    return NULL;
}

struct Node *RInsert(struct Node *p, int key)
{
    struct Node *t = NULL;

    if (p == NULL)
    {
        t = (struct Node *)malloc(sizeof(struct Node));
        t->data = key;
        t->lchild = t->rchild = NULL;
        return t;
    }
    if (key < p->data)
        p->lchild = RInsert(p->lchild, key);
    else if (key > p->data)
        p->rchild = RInsert(p->rchild, key);

    return p;
}

int Height(struct Node *p)
{
    int x, y;
    if (p == NULL)
        return 0;
    x = Height(p->lchild);
    y = Height(p->rchild);
    return x > y ? x + 1 : y + 1;
}

struct Node *InPre(struct Node *p)
{
    while (p && p->rchild != NULL)
        p = p->rchild;

    return p;
}

struct Node *InSucc(struct Node *p)
{
    while (p && p->lchild != NULL)
        p = p->lchild;

    return p;
}

struct Node *Delete(struct Node *p, int key)
{
    struct Node *q;

    if (p == NULL)
        return NULL;
    if (p->lchild == NULL && p->rchild == NULL)
    {
        if (p == root)
            root = NULL;
        free(p);
        return NULL;
    }

    if (key < p->data)
        p->lchild = Delete(p->lchild, key);
    else if (key > p->data)
        p->rchild = Delete(p->rchild, key);
    else
    {
        if (Height(p->lchild) > Height(p->rchild))
        {
            q = InPre(p->lchild);
            p->data = q->data;
            p->lchild = Delete(p->lchild, q->data);
        }
        else
        {
            q = InSucc(p->rchild);
            p->data = q->data;
            p->rchild = Delete(p->rchild, q->data);
        }
    }
    return p;
}

int main()
{
    struct Node *temp;

    root = RInsert(root, 50);
    RInsert(root, 10);
    RInsert(root, 40);
    RInsert(root, 20);
    RInsert(root, 30);

    Delete(root, 30);

    Inorder(root);
    printf("\n");

    temp = Search(20);
    if (temp != NULL)
        printf("element %d is found\n", temp->data);
    else
        printf("element is not found\n");

    return 0;
}

//AVL tree

#include <stdio.h>

struct Node
{
    struct Node *lchild;
    int data;
    int height;
    struct Node *rchild;
} *root = NULL;

int NodeHeight(struct Node *p)
{
    int hl, hr;
    hl = p && p->lchild ? p->lchild->height : 0;
    hr = p && p->rchild ? p->rchild->height : 0;

    return hl > hr ? hl + 1 : hr + 1;
}

int BalanceFactor(struct Node *p)
{
    int hl, hr;
    hl = p && p->lchild ? p->lchild->height : 0;
    hr = p && p->rchild ? p->rchild->height : 0;

    return hl - hr;
}

struct Node *LLRotation(struct Node *p)
{
    struct Node *pl = p->lchild;
    struct Node *plr = pl->rchild;

    pl->rchild = p;
    p->lchild = plr;
    p->height = NodeHeight(p);
    pl->height = NodeHeight(pl);

    if (root == p)
        root = pl;

    return pl;
}

struct Node *LRRotation(struct Node *p)
{
    struct Node *pl = p->lchild;
    struct Node *plr = pl->rchild;

    pl->rchild = plr->lchild;
    p->lchild = plr->rchild;

    plr->lchild = pl;
    plr->rchild = p;

    pl->height = NodeHeight(pl);
    p->height = NodeHeight(p);
    plr->height = NodeHeight(plr);

    if (root == p)
        root = plr;
    return plr;
}

struct Node *RRRotation(struct Node *p)
{
    return NULL;
}

struct Node *RLRotation(struct Node *p)
{
    return NULL;
}

struct Node *RInsert(struct Node *p, int key)
{
    struct Node *t = NULL;

    if (p == NULL)
    {
        t = (struct Node *)malloc(sizeof(struct Node));
        t->data = key;
        t->height = 1;
        t->lchild = t->rchild = NULL;
        return t;
    }
    if (key < p->data)
        p->lchild = RInsert(p->lchild, key);
    else if (key > p->data)
        p->rchild = RInsert(p->rchild, key);

    p->height = NodeHeight(p);

    if (BalanceFactor(p) == 2 && BalanceFactor(p->lchild) == 1)
        return LLRotation(p);
    else if (BalanceFactor(p) == 2 && BalanceFactor(p->lchild) == -1)
        return LRRotation(p);
    else if (BalanceFactor(p) == -2 && BalanceFactor(p->rchild) == -1)
        return RRRotation(p);
    else if (BalanceFactor(p) == -2 && BalanceFactor(p->rchild) == 1)
        return RLRotation(p);
    return p;
}

int main()
{
    root = RInsert(root, 50);
    RInsert(root, 10);
    RInsert(root, 20);

    return 0;
}

//Heap Sort

#include <stdio.h>

void Insert(int A[],int n){
    int i=n,temp;
    temp=A[i];
    while(i>1 && temp>A[i/2]){
        A[i]=A[i/2];
        i=i/2;
    }
    A[i]=temp;
}

int Delete(int A[],int n){
    int i,j,x,temp,val;
    val=A[1];
    
    x=A[n];
    A[1]=A[n];
    A[n]=val;
    i=1;j=1*2;
    
    while(j<n-1){
        if(A[j+1]>A[j])
            j=j+1;
        if(A[i]<A[j]){
            temp=A[i];
            A[i]=A[j];
            A[j]=temp;
            i=j;
            j=2*j;
        }
        else
            break;
    }
    return val;
}

int main(){
    int H[]={0,10,20,30,25,5,40,35};
    //40,25,35,10,5,20,30 --->max heap
    int i;
    
    for(i=2; i<=7; i++)
        Insert(H, i);
    
   // printf("Deleted value is %d \n",Delete(H, 7));
    
    for(i=7;i>1;i--){
        Delete(H, i);       //will give sorted list
    }
    
//    Insert(H, 2);
//    Insert(H, 3);
//    Insert(H, 4);
//    Insert(H, 5);
    for(i=1; i<=7; i++)
        printf("%d ",H[i]);
    printf("\n");
    return 0;
}

//Sorting techniques
//Bubble sort

#include <stdio.h>

void swap(int *x, int *y){
    int temp = *x;
    *x = *y;
    *y = temp;
    
}

void Bubble(int A[], int n){
    int i,j,flag=0;
    for(i=0; i<n-1; i++){
        for(j=0; j<n-i-1; j++){
            if(A[j]>A[j+1]){
                swap(&A[j],&A[j+1]);
                flag=1;
            }
        }
        if(flag==0)
            break;
    }
}

int main(){
    int A[] = {3,7,9,10,6,5,12,4,11,2}, n=10,i;
    Bubble(A, n);
    for(i=0;i<10;i++){
        printf("%d ",A[i]);
    }
    printf("\n");
    return 0;
}

//Insertion Sort

#include <stdio.h>

void Insertion(int A[], int n){
    int i,j,x;
    for(i=1; i<n; i++){
        j=i-1;
        x=A[i];
        while(j>-1 && A[j]>x){
            A[j+1] = A[j];
            j--;
        }
        A[j+1]=x;
    }
}

int main(){
    int A[] = {3,7,9,10,6,5,12,4,11,2}, n=10,i;
    Insertion(A, n);
    for(i=0;i<10;i++){
        printf("%d ",A[i]);
    }
    printf("\n");
    return 0;
}

//Selection Sort

#include <stdio.h>

void swap(int *x, int *y){
    int temp = *x;
    *x = *y;
    *y = temp;
    
}

void Selection(int A[], int n){
    int i,j,k;
    for(i=0; i<n-1; i++){
        for(j=k=i; j<n; j++){
            if(A[j]<A[k])
                k=j;
        }
        swap(&A[i], &A[k]);
    }
}

int main(){
    int A[] = {3,7,9,10,6,5,12,4,11,2}, n=10,i;
    Selection(A, n);
    for(i=0;i<10;i++){
        printf("%d ",A[i]);
    }
    printf("\n");
    return 0;
}

//quick Sort

#include <stdio.h>

void swap(int *x, int *y){
    int temp = *x;
    *x = *y;
    *y = temp;
    
}

int partition(int A[], int l, int h){
    int pivot = A[l];
    int i=l, j=h;
    
    do{
        do{i++;}while(A[i]<=pivot);
        do{j--;}while(A[j]>pivot);
        
        if(i<j)swap(&A[i], &A[j]);
    }while(i<j);
    
    swap(&A[l], &A[j]);
    return j;
}

void Quick(int A[], int l, int h){
    int j;
    
    if(l<h){
        j=partition(A, l, h);
        Quick(A, l, j);
        Quick(A, j+1, h);
    }
}

int main(){
    int A[] = {3,7,9,10,6,5,12,4,11,2,__INT32_MAX__}, n=11,i;   //INT_MAX will act as infinity
    
    Quick(A, 0, n-1);
    
    for(i=0;i<10;i++){
        printf("%d ",A[i]);
    }
    printf("\n");
    return 0;
}


//iterative Merge Sort(2 way)

#include <stdio.h>

void Merge(int A[], int l, int mid, int h){         //first we'll merge the lists
    int i=l,j=mid+1,k=l;
    int B[100];
    
    while(i<=mid && j<=h){
        if(A[i]<A[j])
            B[k++] = A[i++];
        else
            B[k++] = A[j++];
    }
    for(; i<=mid; i++)
        B[k++] = A[i];
    for(; j<=h; j++)
        B[k++] = A[j];
    
    for(int i=l; i<=h; i++)
        A[i] = B[i];
}

void IMergeSort(int A[], int n){
    int p,l,h,mid,i;
    
    for(p=2; p<=n; p=p*2){
        for(i=0; i+p-1<n; i=i+p){
            l=i;
            h=i+p-1;
            mid=(l+h)/2;
            Merge(A, l, mid, h);
        }
    }
    if(p/2<n)
        Merge(A, 0, p/2-1, n-1);
}

int main(){
    int A[] = {3,7,9,10,6,5,12,4,11,2}, n=10,i;
    
    IMergeSort(A, n);
    
    for(i=0;i<10;i++){
        printf("%d ",A[i]);
    }
    printf("\n");
    return 0;
}


//Recursive Merge Sort
#include <stdio.h>

void Merge(int A[], int l, int mid, int h){         //first we'll merge the lists
    int i=l,j=mid+1,k=l;
    int B[100];
    
    while(i<=mid && j<=h){
        if(A[i]<A[j])
            B[k++] = A[i++];
        else
            B[k++] = A[j++];
    }
    for(; i<=mid; i++)
        B[k++] = A[i];
    for(; j<=h; j++)
        B[k++] = A[j];
    
    for(int i=l; i<=h; i++)
        A[i] = B[i];
}

void RMergeSort(int A[], int l, int h){
    int mid;
    
    if(l<h){
        mid=(l+h)/2;
        RMergeSort(A, l, mid);
        RMergeSort(A, mid+1, h);
        Merge(A, l, mid, h);
    }
}

int main(){
    int A[] = {3,7,9,10,6,5,12,4,11,2,}, n=10,i;
    
    RMergeSort(A, 0, n-1);
    
    for(i=0;i<10;i++){
        printf("%d ",A[i]);
    }
    printf("\n");
    return 0;
}


//Count Sort

#include <stdio.h>
#include <stdlib.h>

void swap(int *x, int *y){
    int temp = *x;
    *x = *y;
    *y = temp;
    
}

int findMax(int A[], int n){
    int max = INT32_MIN;
    int i;
    for(i=0; i<n; i++){
        if(A[i]>max)
            max=A[i];
    }
    return max;
}

void CountSort(int A[], int n){
    int i,j,max=findMax(A, n),*C;
    
    C=(int *)malloc(sizeof(int)*(max+1));
    for(i=0; i<max+1; i++){
        C[i]=0;
    }
    for(i=0; i<n; i++){
        C[A[i]]++;
    }
    i=0;j=0;
    while(j<max+1){
        if(C[j]>0){
            A[i++]=j;
            C[j]--;
        }
        else
            j++;
    }
}

int main(){
    int A[] = {3,7,9,10,6,5,12,4,11,2,}, n=10,i;
    
    CountSort(A, n);
    
    for(i=0;i<10;i++){
        printf("%d ",A[i]);
    }
    printf("\n");
    return 0;
}


//shell sort

#include <stdio.h>
#include <stdlib.h>

void ShellSort(int A[], int n){
    int gap, i, j, temp;
    for(gap=n/2; gap>=1; gap/=2){
        for(i=gap; i<n; i++){
            temp=A[i];
            j=i-gap;
            while(j>=0 && A[j]>temp){
                A[j+gap] = A[j];
                j=j-gap;
            }
            A[j+gap]=temp;
        }
    }
}

int main(){
    int A[] = {3,7,9,10,6,5,12,4,11,2,}, n=10,i;
    
    ShellSort(A, n);
    
    for(i=0;i<10;i++){
        printf("%d ",A[i]);
    }
    printf("\n");
    return 0;
}

//hashing using chaining

#include <stdio.h>
#include <stdlib.h>

struct Node{
    int data;
    struct Node *next;
};

void SortedInsert(struct Node **H, int x){
    struct Node *t, *q=NULL, *p=*H;
    
    t=(struct Node *)malloc(sizeof(struct Node));
    t->data=x;
    t->next=NULL;
    
    if(*H==NULL)
        *H=t;
    else{
        while(p && p->data<x){
            q=p;
            p=p->next;
        }
        if(p==*H){
            t->next=*H;
            *H = t;
        }
        else{
            t->next=q->next;
            q->next=t;
        }
    }
}

struct Node *Search(struct Node *p, int key){
    while (p!=NULL) {
        if(key==p->data){
            return p;
        }
        p=p->next;
    }
    return NULL;
}

int hash(int key){
    return key%10;
}

void Insert(struct Node *H[], int key){
    int index = hash(key);
    SortedInsert(&H[index], key);
}

int main(){
    struct Node *HT[10];
    struct Node *temp;
    int i;
    
    for(i=0; i<10; i++)
        HT[i]=NULL;
    
    Insert(HT, 12);
    Insert(HT, 22);
    Insert(HT, 42);
    
    temp=Search(HT[hash(22)],22);
    printf("%d ",temp->data);
    
    return 0;
}


//hashing using linear probing

#include <stdio.h>
#include <stdlib.h>
#define SIZE 10

int hash(int key){
    return key%SIZE;
}

int probe(int H[], int key){
    int index = hash(key);
    int i=0;
    while(H[(index+i)%SIZE]!=0)            //for quadratic probing everything's same just                                           change (index+i) -> (index + i*i)
        i++;
    return (index+i)%SIZE;
}

void Insert(int H[], int key){
    int index = hash(key);
    
    if(H[index]!=0)
        index = probe(H,key);
    H[index]=key;
}

int Search(int H[], int key){
    int index = hash(key);
    int i=0;
    while (H[(index+i)%SIZE]!=key) {
        i++;
    }
    return (index+i)%SIZE;
}

int main(){
    int HT[10]={0};
    
    Insert(HT, 12);
    Insert(HT, 25);
    Insert(HT, 35);
    Insert(HT, 26);
    
    printf("\nKey found at %d\n", Search(HT, 35));
    
    return 0;
}


//DFS and BFS

#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node *next;
} *front = NULL, *rear = NULL;

void enqueue(int x) {
    struct Node *t;
    t = (struct Node *)malloc(sizeof(struct Node));
    if (t == NULL)
        printf("Queue is FUll\n");
    else {
        t->data = x;
        t->next = NULL;
        if (front == NULL)
            front = rear = t;
        else {
            rear->next = t;
            rear = t;
        }
    }
}

int dequeue() {
    int x = -1;
    struct Node *t;

    if (front == NULL)
        printf("Queue is Empty\n");
    else {
        x = front->data;
        t = front;
        front = front->next;
        free(t);
    }
    return x;
}

int isEmpty() {
    return front == NULL;
}

void BFS(int G[][7], int start, int n) {
    int i = start, j;

    int visited[7] = {0};

    printf("%d ", i);
    visited[i] = 1;
    enqueue(i);

    while (!isEmpty()) {
        i = dequeue();
        for (j = 1; j < n; j++) {
            if (G[i][j] == 1 && visited[j] == 0) {
                printf("%d ", j);
                visited[j] = 1;
                enqueue(j);
            }
        }
    }
}

void DFS(int G[][7], int start, int n) {
    static int visited[7] = {0};
    int j;

    if (visited[start] == 0) {
        printf("%d ", start);
        visited[start] = 1;

        for (j = 1; j < n; j++) {
            if (G[start][j] == 1 && visited[j] == 0)
                DFS(G, j, n);
        }
    }
}

int main() {
    int G[7][7] = {{0, 0, 0, 0, 0, 0, 0},
                  {0, 0, 1, 1, 0, 0, 0},
                  {0, 1, 0, 0, 1, 0, 0},
                  {0, 1, 0, 0, 1, 0, 0},
                  {0, 0, 1, 1, 0, 1, 1},
                  {0, 0, 0, 0, 1, 0, 0},
                  {0, 0, 0, 0, 1, 0, 0}};
    DFS(G, 4, 7);

    return 0;
}


//Prim's algo using C++

#include <iostream>
#define I INT_MAX
using namespace std;

int cost[][8] =
{
    {I, I, I, I, I, I, I, I},
    {I, I, 25, I, I, I, 5, I},
    {I, 25, I, 12, I, I, I, 10},
    {I, I, 12, I, 8, I, I, I},
    {I, I, I, 8, I, 16, I, 14},
    {I, I, I, I, 16, I, 20, 18},
    {I, 5, I, I, I, 20, I, I},
    {I, I, 10, I, 14, 18, I, I}
};

int near[8] = {I, I, I, I, I, I, I, I};
int t[2][6];

int main()
{
    int i, j, k, u, v, n = 7, min = I;

    // Find the minimum cost edge in the graph
    for (i = 1; i <= n; i++)
    {
        for (j = i; j <= n; j++)
        {
            if (cost[i][j] < min)
            {
                min = cost[i][j];
                u = i;
                v = j;
            }
        }
    }

    // Store the minimum cost edge in t
    t[0][0] = u;
    t[1][0] = v;
    near[u] = near[v] = 0;

    // Update the 'near' array based on the newly added vertex
    for (i = 1; i <= n; i++)
    {
        if (near[i] != 0)
        {
            if (cost[i][u] < cost[i][v])
                near[i] = u;
            else
                near[i] = v;
        }
    }

    // Find the remaining edges for the minimum spanning tree
    for (i = 1; i < n - 1; i++)
    {
        min = I;
        for (j = 1; j <= n; j++)
        {
            if (near[j] != 0 && cost[j][near[j]] < min)
            {
                k = j;
                min = cost[j][near[j]];
            }
        }

        // Store the next edge in t
        t[0][i] = k;
        t[1][i] = near[k];
        near[k] = 0;

        // Update the 'near' array
        for (j = 1; j <= n; j++)
        {
            if (near[j] != 0 && cost[j][k] < cost[j][near[j]])
                near[j] = k;
        }
    }

    // Print the edges of the minimum spanning tree
    for (i = 0; i < n - 1; i++)
    {
        cout << "(" << t[0][i] << "," << t[1][i] << ")" << endl;
    }

    return 0;
}


//Kruskal's algo using C++

#include <stdio.h>
#define I 65535

int edge[9][3] = {{1, 2, 28}, {1, 6, 10}, {2, 3, 16}, {2, 7, 14}, {3, 4, 12},
                 {4, 5, 22}, {4, 7, 18}, {5, 6, 25}, {5, 7, 24}};

int set[8] = {-1, -1, -1, -1, -1, -1, -1, -1};
int included[9] = {0, 0, 0, 0, 0, 0, 0, 0, 0};

void join(int u, int v) {
    if (set[u] < set[v]) {
        set[u] += set[v];
        set[v] = u;
    } else {
        set[v] += set[u];
        set[u] = v;
    }
}

int find(int u) {
    int x = u, v = 0;
    while (set[x] > 0) {
        x = set[x];
    }
    while (u != x) {
        v = set[u];
        set[u] = x;
        u = v;
    }
    return x;
}

int t[2][7];

int main(int argc, const char *argv[]) {
    int u = 0, v = 0, i, j, k = 0, min = 65535, n = 9;
    i = 0;

    while (i < 6) {
        min = 65535;
        for (j = 0; j < n; j++) {
            if (included[j] == 0 && edge[j][2] < min) {
                u = edge[j][0];
                v = edge[j][1];
                min = edge[j][2];
                k = j;
            }
        }
        if (find(u) != find(v)) {
            t[0][i] = u;
            t[1][i] = v;
            join(find(u), find(v));
            included[k] = 1;
            i++;
            // printf("%d %d %d %d\n", u, v, find(u), find(v));
        } else {
            included[k] = 1;
        }
    }

    printf("Spanning Tree\n");
    for (i = 0; i < 6; i++) {
        printf("(%d,%d)\n", t[0][i], t[1][i]);
    }

    return 0;
}


//STL
//vectors  (array)

#include <iostream>
#include <vector>
using namespace std;

int main(){
    vector<int> v={2,4,6,8,10};
    v.push_back(20);
    v.push_back(30);
    
    v.pop_back();
    vector<int>::iterator itr;
    cout<<"Using iterator\n"<<endl;
    for(itr=v.begin(); itr!=v.end(); itr++)
        cout<<++*itr<<endl;
    
    printf("Using for each loop\n");
    for(int x :v)
        cout<<x<<endl;
    return 0;
}


//list     (doubly-linked list)

#include <iostream>
#include <list>
using namespace std;

int main(){
    list<int> v={2,4,6,8,10};
    v.push_back(20);
    v.push_back(30);
    
    v.pop_back();
    list<int>::iterator itr;
    cout<<"Using iterator\n"<<endl;
    for(itr=v.begin(); itr!=v.end(); itr++)
        cout<<++*itr<<endl;
    
    printf("Using for each loop\n");
    for(int x :v)
        cout<<x<<endl;
    return 0;
}


//forward list (single LL)

#include <iostream>
#include <forward_list>
using namespace std;

int main(){
    forward_list<int> v={2,4,6,8,10};
    v.push_front(20);
    v.push_front(30);
    
 
    forward_list<int>::iterator itr;
    cout<<"Using iterator\n"<<endl;
    for(itr=v.begin(); itr!=v.end(); itr++)
        cout<<++*itr<<endl;
    
    printf("Using for each loop\n");
    for(int x :v)
        cout<<x<<endl;
    return 0;
}


//set

#include <iostream>
#include <set>
using namespace std;

int main(){
    set<int> v={2,4,6,8,10,10};             //output will only give unique values
    v.insert(20);
    v.insert(30);
    
 
   set<int>::iterator itr;
    cout<<"Using iterator\n"<<endl;
    for(itr=v.begin(); itr!=v.end(); itr++)
        cout<<*itr<<endl;               //we cannot modify them
    
    printf("Using for each loop\n");
    for(int x :v)
        cout<<x<<endl;
    return 0;
}


//Map

#include <iostream>
#include <map>
using namespace std;

int main(){
    
    map<int,string> m;
    m.insert(pair<int,string>(1,"john"));
    m.insert(pair<int,string>(2,"Karan"));
    m.insert(pair<int,string>(3,"Nidhi"));
    
    map<int,string>::iterator itr;
    for(itr=m.begin(); itr!=m.end(); itr++)
    {
        cout<<itr->first<<" "<<itr->second<<endl;
    }
    
    map<int,string>::iterator itr1;
    itr1=m.find(2);
    cout<<"Value found is : "<<endl;
    cout<<itr1->first<<" "<<itr1->second<<endl;
    
    return 0;
}


//program to store items in a file using vector class

#include<iostream>
#include<fstream>
#include<vector>
using namespace std;

class Item {
private:
    string name;
    float price;
    int qty;

public:
    Item() {}
    Item(string n, float p, int q);
    friend ifstream &operator>>(ifstream &fis, Item &i);
    friend ofstream &operator<<(ofstream &fos, Item &i);
    friend ostream &operator<<(ostream &os, Item &i);
};

Item::Item(string n, float p, int q) {
    name = n;
    price = p;
    qty = q;
}

ofstream &operator<<(ofstream &fos, Item &i) {
    fos << i.name << endl << i.price << endl << i.qty << endl;
    return fos;
}

ifstream &operator>>(ifstream &fis, Item &i) {
    fis >> i.name >> i.price >> i.qty;
    return fis;
}

ostream &operator<<(ostream &os, Item &i) {
    os << i.name << endl << i.price << endl << i.qty << endl;
    return os;
}

int main() {
    int n;
    string name;
    float price;
    int qty;

    cout << "Enter number of Items: ";
    cin >> n;

    vector<Item *> list;

    cout << "Enter All Items:" << endl;
    for (int i = 0; i < n; i++) {
        cout << "Enter " << i + 1 << " Item Name, price, and quantity: ";
        cin >> name >> price >> qty;
        list.push_back(new Item(name, price, qty));
    }

    ofstream fos("Items.txt");
    vector<Item *>::iterator itr;

    for (itr = list.begin(); itr != list.end(); itr++) {
        fos << **itr;
    }

    Item item;
    ifstream fis("Items.txt");
    for (int i = 0; i < 3; i++) {
        fis >> item;
        cout << "Item " << i << ":" << endl << item << endl;
    }

    return 0;
}  */
